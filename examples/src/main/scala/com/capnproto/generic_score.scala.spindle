
/**
 * GENERATED CODE - DO NOT EDIT!
 * Generated by foursquare.thrift.codegen
 * 

 */


package com.foursquare.math.gen

import scalaj.collection.Imports._





object GenericScoreTypedefs {

  type ObjectId = com.foursquare.common.types.gen.TypesTypedefs.ObjectId  // Underlying type: java.nio.ByteBuffer
}



object GenericScore
    extends com.foursquare.spindle.MetaRecord[GenericScore]
    with com.foursquare.spindle.RecordProvider[GenericScore] {
  override def recordName: String = "GenericScore"


  // Thrift descriptors.
  val GENERICSCORE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("GenericScore")

  val AGGREGATEBY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "aggregateBy",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val SCORE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "score",
      org.apache.thrift.protocol.TType.DOUBLE,
      3,
      Map[String, String]().asJava
    )
  val ATTRIBUTETOSCORE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "attributeToScore",
      org.apache.thrift.protocol.TType.MAP,
      4,
      Map[String, String]().asJava
    )
  val UID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "uid",
      org.apache.thrift.protocol.TType.I64,
      5,
      Map[String, String]().asJava
    )
  val OID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "oid",
      org.apache.thrift.protocol.TType.STRING,
      6,
      Map[String, String]("bson" -> "ObjectId").asJava
    )
  val OIDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "oids",
      org.apache.thrift.protocol.TType.LIST,
      7,
      Map[String, String]("bson" -> "ObjectId").asJava
    )
  val CONFIDENCE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "confidence",
      org.apache.thrift.protocol.TType.DOUBLE,
      8,
      Map[String, String]().asJava
    )
  val GEOSHARDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "geoshards",
      org.apache.thrift.protocol.TType.LIST,
      9,
      Map[String, String]().asJava
    )
  val SOURCE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "source",
      org.apache.thrift.protocol.TType.STRING,
      10,
      Map[String, String]().asJava
    )
  val GEOIDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "geoIds",
      org.apache.thrift.protocol.TType.LIST,
      11,
      Map[String, String]().asJava
    )
  val GEOCODEFEATURES_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "geocodeFeatures",
      org.apache.thrift.protocol.TType.STRUCT,
      12,
      Map[String, String]().asJava
    )
  val FEATUREINDEX_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "featureIndex",
      org.apache.thrift.protocol.TType.I32,
      13,
      Map[String, String]().asJava
    )
  val SAMPLEWEIGHT_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "sampleWeight",
      org.apache.thrift.protocol.TType.DOUBLE,
      14,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "aggregateBy" -> AGGREGATEBY_DESC,
    "name" -> NAME_DESC,
    "score" -> SCORE_DESC,
    "attributeToScore" -> ATTRIBUTETOSCORE_DESC,
    "uid" -> UID_DESC,
    "oid" -> OID_DESC,
    "oids" -> OIDS_DESC,
    "confidence" -> CONFIDENCE_DESC,
    "geoshards" -> GEOSHARDS_DESC,
    "source" -> SOURCE_DESC,
    "geoIds" -> GEOIDS_DESC,
    "geocodeFeatures" -> GEOCODEFEATURES_DESC,
    "featureIndex" -> FEATUREINDEX_DESC,
    "sampleWeight" -> SAMPLEWEIGHT_DESC
  )

  object _Fields {
    case object aggregateBy extends _Fields(1, "aggregateBy")
    case object name extends _Fields(2, "name")
    case object score extends _Fields(3, "score")
    case object attributeToScore extends _Fields(4, "attributeToScore")
    case object uid extends _Fields(5, "uid")
    case object oid extends _Fields(6, "oid")
    case object oids extends _Fields(7, "oids")
    case object confidence extends _Fields(8, "confidence")
    case object geoshards extends _Fields(9, "geoshards")
    case object source extends _Fields(10, "source")
    case object geoIds extends _Fields(11, "geoIds")
    case object geocodeFeatures extends _Fields(12, "geocodeFeatures")
    case object featureIndex extends _Fields(13, "featureIndex")
    case object sampleWeight extends _Fields(14, "sampleWeight")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.aggregateBy,
    2.toShort -> _Fields.name,
    3.toShort -> _Fields.score,
    4.toShort -> _Fields.attributeToScore,
    5.toShort -> _Fields.uid,
    6.toShort -> _Fields.oid,
    7.toShort -> _Fields.oids,
    8.toShort -> _Fields.confidence,
    9.toShort -> _Fields.geoshards,
    10.toShort -> _Fields.source,
    11.toShort -> _Fields.geoIds,
    12.toShort -> _Fields.geocodeFeatures,
    13.toShort -> _Fields.featureIndex,
    14.toShort -> _Fields.sampleWeight
  )

  // Record v2
  override type Self = GenericScore.type
  override type Trait = GenericScore
  override type Mutable = MutableGenericScore
  override type Raw = RawGenericScore

  override def createRecord: GenericScore = createRawRecord
  override def createRawRecord: GenericScore.Raw = new GenericScore.Raw

  override def ifInstanceFrom(x: AnyRef): Option[GenericScore] = {
    if (x.isInstanceOf[GenericScore]) Some(x.asInstanceOf[GenericScore]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val aggregateBy =

    new com.foursquare.spindle.OptionalFieldDescriptor[java.nio.ByteBuffer, GenericScore, GenericScore.type](
      name = "aggregateBy",
      longName = "aggregateBy",
      id = 1,
      annotations = Map(),
      owner = GenericScore,
      getter = _.aggregateByOption,
      setterRaw = (r: GenericScore.Raw, v: java.nio.ByteBuffer) => { r.aggregateBy_=(v) },
      manifest = manifest[java.nio.ByteBuffer]
    )

  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, GenericScore, GenericScore.type](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = GenericScore,
      getter = _.nameOption,
      setterRaw = (r: GenericScore.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val score =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericScore, GenericScore.type](
      name = "score",
      longName = "score",
      id = 3,
      annotations = Map(),
      owner = GenericScore,
      getter = _.scoreOption,
      setterRaw = (r: GenericScore.Raw, v: Double) => { r.score_=(v) },
      manifest = manifest[Double]
    )

  val attributeToScore =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.immutable.Map[String, Double], GenericScore, GenericScore.type](
      name = "attributeToScore",
      longName = "attributeToScore",
      id = 4,
      annotations = Map(),
      owner = GenericScore,
      getter = _.attributeToScoreOption,
      setterRaw = (r: GenericScore.Raw, v: scala.collection.immutable.Map[String, Double]) => { r.attributeToScore_=(v) },
      manifest = manifest[scala.collection.immutable.Map[String, Double]]
    )

  val uid =

    new com.foursquare.spindle.OptionalFieldDescriptor[Long, GenericScore, GenericScore.type](
      name = "uid",
      longName = "uid",
      id = 5,
      annotations = Map(),
      owner = GenericScore,
      getter = _.uidOption,
      setterRaw = (r: GenericScore.Raw, v: Long) => { r.uid_=(v) },
      manifest = manifest[Long]
    )

  val oid =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId, GenericScore, GenericScore.type](
      name = "oid",
      longName = "oid",
      id = 6,
      annotations = Map(),
      owner = GenericScore,
      getter = _.oidOption,
      setterRaw = (r: GenericScore.Raw, v: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId) => { r.oid_=(v) },
      manifest = manifest[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
    )

  val oids =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId], GenericScore, GenericScore.type](
      name = "oids",
      longName = "oids",
      id = 7,
      annotations = Map(),
      owner = GenericScore,
      getter = _.oidsOption,
      setterRaw = (r: GenericScore.Raw, v: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]) => { r.oids_=(v) },
      manifest = manifest[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]]
    )

  val confidence =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericScore, GenericScore.type](
      name = "confidence",
      longName = "confidence",
      id = 8,
      annotations = Map(),
      owner = GenericScore,
      getter = _.confidenceOption,
      setterRaw = (r: GenericScore.Raw, v: Double) => { r.confidence_=(v) },
      manifest = manifest[Double]
    )

  val geoshards =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[String], GenericScore, GenericScore.type](
      name = "geoshards",
      longName = "geoshards",
      id = 9,
      annotations = Map(),
      owner = GenericScore,
      getter = _.geoshardsOption,
      setterRaw = (r: GenericScore.Raw, v: scala.collection.Seq[String]) => { r.geoshards_=(v) },
      manifest = manifest[scala.collection.Seq[String]]
    )

  val source =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, GenericScore, GenericScore.type](
      name = "source",
      longName = "source",
      id = 10,
      annotations = Map(),
      owner = GenericScore,
      getter = _.sourceOption,
      setterRaw = (r: GenericScore.Raw, v: String) => { r.source_=(v) },
      manifest = manifest[String]
    )

  val geoIds =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[Long], GenericScore, GenericScore.type](
      name = "geoIds",
      longName = "geoIds",
      id = 11,
      annotations = Map(),
      owner = GenericScore,
      getter = _.geoIdsOption,
      setterRaw = (r: GenericScore.Raw, v: scala.collection.Seq[Long]) => { r.geoIds_=(v) },
      manifest = manifest[scala.collection.Seq[Long]]
    )

  val geocodeFeatures =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.foursquare.twofishes.gen.GeocodeFeatures, GenericScore, GenericScore.type](
      name = "geocodeFeatures",
      longName = "geocodeFeatures",
      id = 12,
      annotations = Map(),
      owner = GenericScore,
      getter = _.geocodeFeaturesOption,
      setterRaw = (r: GenericScore.Raw, v: com.foursquare.twofishes.gen.GeocodeFeatures) => { r.geocodeFeatures_=(v) },
      manifest = manifest[com.foursquare.twofishes.gen.GeocodeFeatures]
    )

  val featureIndex =

    new com.foursquare.spindle.OptionalFieldDescriptor[Int, GenericScore, GenericScore.type](
      name = "featureIndex",
      longName = "featureIndex",
      id = 13,
      annotations = Map(),
      owner = GenericScore,
      getter = _.featureIndexOption,
      setterRaw = (r: GenericScore.Raw, v: Int) => { r.featureIndex_=(v) },
      manifest = manifest[Int]
    )

  val sampleWeight =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericScore, GenericScore.type](
      name = "sampleWeight",
      longName = "sampleWeight",
      id = 14,
      annotations = Map(),
      owner = GenericScore,
      getter = _.sampleWeightOption,
      setterRaw = (r: GenericScore.Raw, v: Double) => { r.sampleWeight_=(v) },
      manifest = manifest[Double]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, GenericScore, GenericScore.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, GenericScore, GenericScore.type]](
      aggregateBy,
      name,
      score,
      attributeToScore,
      uid,
      oid,
      oids,
      confidence,
      geoshards,
      source,
      geoIds,
      geocodeFeatures,
      featureIndex,
      sampleWeight
    )


  def apply(
      aggregateBy: java.nio.ByteBuffer,
      name: String,
      score: Double,
      attributeToScore: scala.collection.immutable.Map[String, Double],
      uid: Long,
      oid: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId],
      confidence: Double,
      geoshards: scala.collection.Seq[String],
      source: String,
      geoIds: scala.collection.Seq[Long],
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures,
      featureIndex: Int,
      sampleWeight: Double
  ): GenericScore = {
    val ret = GenericScore.createRawRecord
    ret.aggregateBy_=(aggregateBy)
    ret.name_=(name)
    ret.score_=(score)
    ret.attributeToScore_=(attributeToScore)
    ret.uid_=(uid)
    ret.oid_=(oid)
    ret.oids_=(oids)
    ret.confidence_=(confidence)
    ret.geoshards_=(geoshards)
    ret.source_=(source)
    ret.geoIds_=(geoIds)
    ret.geocodeFeatures_=(geocodeFeatures)
    ret.featureIndex_=(featureIndex)
    ret.sampleWeight_=(sampleWeight)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[GenericScore] (private var obj: GenericScore.Raw) {

    def aggregateBy(v: java.nio.ByteBuffer): GenericScore.Builder[State] = {
      obj.aggregateBy_=(v)
      this
    }

    def aggregateBy(vOpt: Option[java.nio.ByteBuffer]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.aggregateBy_=(v)
        case None => obj.aggregateByUnset()
      }
      this
    }

    def name(v: String): GenericScore.Builder[State] = {
      obj.name_=(v)
      this
    }

    def name(vOpt: Option[String]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.name_=(v)
        case None => obj.nameUnset()
      }
      this
    }

    def score(v: Double): GenericScore.Builder[State] = {
      obj.score_=(v)
      this
    }

    def score(vOpt: Option[Double]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.score_=(v)
        case None => obj.scoreUnset()
      }
      this
    }

    def attributeToScore(v: scala.collection.immutable.Map[String, Double]): GenericScore.Builder[State] = {
      obj.attributeToScore_=(v)
      this
    }

    def attributeToScore(vOpt: Option[scala.collection.immutable.Map[String, Double]]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.attributeToScore_=(v)
        case None => obj.attributeToScoreUnset()
      }
      this
    }

    def uid(v: Long): GenericScore.Builder[State] = {
      obj.uid_=(v)
      this
    }

    def uid(vOpt: Option[Long]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.uid_=(v)
        case None => obj.uidUnset()
      }
      this
    }

    def oid(v: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): GenericScore.Builder[State] = {
      obj.oid_=(v)
      this
    }

    def oid(vOpt: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.oid_=(v)
        case None => obj.oidUnset()
      }
      this
    }

    def oids(v: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): GenericScore.Builder[State] = {
      obj.oids_=(v)
      this
    }

    def oids(vOpt: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.oids_=(v)
        case None => obj.oidsUnset()
      }
      this
    }

    def confidence(v: Double): GenericScore.Builder[State] = {
      obj.confidence_=(v)
      this
    }

    def confidence(vOpt: Option[Double]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.confidence_=(v)
        case None => obj.confidenceUnset()
      }
      this
    }

    def geoshards(v: scala.collection.Seq[String]): GenericScore.Builder[State] = {
      obj.geoshards_=(v)
      this
    }

    def geoshards(vOpt: Option[scala.collection.Seq[String]]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.geoshards_=(v)
        case None => obj.geoshardsUnset()
      }
      this
    }

    def source(v: String): GenericScore.Builder[State] = {
      obj.source_=(v)
      this
    }

    def source(vOpt: Option[String]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.source_=(v)
        case None => obj.sourceUnset()
      }
      this
    }

    def geoIds(v: scala.collection.Seq[Long]): GenericScore.Builder[State] = {
      obj.geoIds_=(v)
      this
    }

    def geoIds(vOpt: Option[scala.collection.Seq[Long]]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.geoIds_=(v)
        case None => obj.geoIdsUnset()
      }
      this
    }

    def geocodeFeatures(v: com.foursquare.twofishes.gen.GeocodeFeatures): GenericScore.Builder[State] = {
      obj.geocodeFeatures_=(v)
      this
    }

    def geocodeFeatures(vOpt: Option[com.foursquare.twofishes.gen.GeocodeFeatures]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.geocodeFeatures_=(v)
        case None => obj.geocodeFeaturesUnset()
      }
      this
    }

    def featureIndex(v: Int): GenericScore.Builder[State] = {
      obj.featureIndex_=(v)
      this
    }

    def featureIndex(vOpt: Option[Int]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.featureIndex_=(v)
        case None => obj.featureIndexUnset()
      }
      this
    }

    def sampleWeight(v: Double): GenericScore.Builder[State] = {
      obj.sampleWeight_=(v)
      this
    }

    def sampleWeight(vOpt: Option[Double]): GenericScore.Builder[State] = {
      vOpt match {
        case Some(v) => obj.sampleWeight_=(v)
        case None => obj.sampleWeightUnset()
      }
      this
    }

    def resultMutable()(): GenericScore.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("GenericScore.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): GenericScore = resultMutable()()
  }

  def newBuilder: GenericScore.Builder.AllUnspecified = new Builder(GenericScore.createRawRecord)

  implicit val companionProvider: GenericScoreCompanionProvider = new GenericScoreCompanionProvider
}

class GenericScoreCompanionProvider extends com.foursquare.spindle.CompanionProvider[GenericScore] {
  type CompanionT = GenericScore.type
  override def provide: GenericScore.type = GenericScore
}



trait GenericScore

    extends com.foursquare.spindle.Record[GenericScore]
    with scala.Ordered[GenericScore]
    with org.apache.thrift.TBase[GenericScore, GenericScore._Fields] {

  override type MetaT = GenericScore.type

  def aggregateByOption: Option[java.nio.ByteBuffer]
  def aggregateByOrNull: java.nio.ByteBuffer
  def aggregateByOrThrow: java.nio.ByteBuffer
  def aggregateByIsSet: Boolean
  def aggregateByByteArray: Array[Byte]
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def score: Double
  def scoreOption: Option[Double]
  def scoreOrDefault: Double
  def scoreOrNull: java.lang.Double
  def scoreOrThrow: Double
  def scoreIsSet: Boolean
  def attributeToScore: scala.collection.immutable.Map[String, Double]
  def attributeToScoreOption: Option[scala.collection.immutable.Map[String, Double]]
  def attributeToScoreOrDefault: scala.collection.immutable.Map[String, Double]
  def attributeToScoreOrNull: scala.collection.immutable.Map[String, Double]
  def attributeToScoreOrThrow: scala.collection.immutable.Map[String, Double]
  def attributeToScoreIsSet: Boolean
  def uid: Long
  def uidOption: Option[Long]
  def uidOrDefault: Long
  def uidOrNull: java.lang.Long
  def uidOrThrow: Long
  def uidIsSet: Boolean
  def oidOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def oidOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId
  def oidOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId
  def oidIsSet: Boolean
  def oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def oidsOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]]
  def oidsOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def oidsOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def oidsOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def oidsIsSet: Boolean
  def confidence: Double
  def confidenceOption: Option[Double]
  def confidenceOrDefault: Double
  def confidenceOrNull: java.lang.Double
  def confidenceOrThrow: Double
  def confidenceIsSet: Boolean
  def geoshards: scala.collection.Seq[String]
  def geoshardsOption: Option[scala.collection.Seq[String]]
  def geoshardsOrDefault: scala.collection.Seq[String]
  def geoshardsOrNull: scala.collection.Seq[String]
  def geoshardsOrThrow: scala.collection.Seq[String]
  def geoshardsIsSet: Boolean
  def sourceOption: Option[String]
  def sourceOrNull: String
  def sourceOrThrow: String
  def sourceIsSet: Boolean
  def geoIds: scala.collection.Seq[Long]
  def geoIdsOption: Option[scala.collection.Seq[Long]]
  def geoIdsOrDefault: scala.collection.Seq[Long]
  def geoIdsOrNull: scala.collection.Seq[Long]
  def geoIdsOrThrow: scala.collection.Seq[Long]
  def geoIdsIsSet: Boolean
  def geocodeFeaturesOption: Option[com.foursquare.twofishes.gen.GeocodeFeatures]
  def geocodeFeaturesOrNull: com.foursquare.twofishes.gen.GeocodeFeatures
  def geocodeFeaturesOrThrow: com.foursquare.twofishes.gen.GeocodeFeatures
  def geocodeFeaturesIsSet: Boolean
  def featureIndex: Int
  def featureIndexOption: Option[Int]
  def featureIndexOrDefault: Int
  def featureIndexOrNull: java.lang.Integer
  def featureIndexOrThrow: Int
  def featureIndexIsSet: Boolean
  def sampleWeight: Double
  def sampleWeightOption: Option[Double]
  def sampleWeightOrDefault: Double
  def sampleWeightOrNull: java.lang.Double
  def sampleWeightOrThrow: Double
  def sampleWeightIsSet: Boolean
  override def compare(that: GenericScore): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.aggregateByIsSet.compareTo(that.aggregateByIsSet)
      cmp != 0 }) cmp
    else if (this.aggregateByIsSet && {
      cmp = this.aggregateByOrNull.compareTo(that.aggregateByOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.scoreIsSet.compareTo(that.scoreIsSet)
      cmp != 0 }) cmp
    else if (this.scoreIsSet && {
      cmp = this.score.compareTo(that.score)
      cmp != 0 }) cmp
    else if ({
      cmp = this.attributeToScoreIsSet.compareTo(that.attributeToScoreIsSet)
      cmp != 0 }) cmp
    else if (this.attributeToScoreIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.attributeToScore.asJava, that.attributeToScore.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.uidIsSet.compareTo(that.uidIsSet)
      cmp != 0 }) cmp
    else if (this.uidIsSet && {
      cmp = this.uid.compareTo(that.uid)
      cmp != 0 }) cmp
    else if ({
      cmp = this.oidIsSet.compareTo(that.oidIsSet)
      cmp != 0 }) cmp
    else if (this.oidIsSet && {
      cmp = this.oidOrNull.compareTo(that.oidOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.oidsIsSet.compareTo(that.oidsIsSet)
      cmp != 0 }) cmp
    else if (this.oidsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.oids.asJava, that.oids.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.confidenceIsSet.compareTo(that.confidenceIsSet)
      cmp != 0 }) cmp
    else if (this.confidenceIsSet && {
      cmp = this.confidence.compareTo(that.confidence)
      cmp != 0 }) cmp
    else if ({
      cmp = this.geoshardsIsSet.compareTo(that.geoshardsIsSet)
      cmp != 0 }) cmp
    else if (this.geoshardsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.geoshards.asJava, that.geoshards.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.sourceIsSet.compareTo(that.sourceIsSet)
      cmp != 0 }) cmp
    else if (this.sourceIsSet && {
      cmp = this.sourceOrNull.compareTo(that.sourceOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.geoIdsIsSet.compareTo(that.geoIdsIsSet)
      cmp != 0 }) cmp
    else if (this.geoIdsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.geoIds.asJava, that.geoIds.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.geocodeFeaturesIsSet.compareTo(that.geocodeFeaturesIsSet)
      cmp != 0 }) cmp
    else if (this.geocodeFeaturesIsSet && {
      cmp = this.geocodeFeaturesOrNull.compareTo(that.geocodeFeaturesOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.featureIndexIsSet.compareTo(that.featureIndexIsSet)
      cmp != 0 }) cmp
    else if (this.featureIndexIsSet && {
      cmp = this.featureIndex.compareTo(that.featureIndex)
      cmp != 0 }) cmp
    else if ({
      cmp = this.sampleWeightIsSet.compareTo(that.sampleWeightIsSet)
      cmp != 0 }) cmp
    else if (this.sampleWeightIsSet && {
      cmp = this.sampleWeight.compareTo(that.sampleWeight)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): GenericScore

  def copy(
      aggregateBy: java.nio.ByteBuffer = aggregateByOrNull,
      name: String = nameOrNull,
      score: java.lang.Double = scoreOrNull,
      attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrNull,
      uid: java.lang.Long = uidOrNull,
      oid: org.bson.types.ObjectId = oidOrNull,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrNull,
      confidence: java.lang.Double = confidenceOrNull,
      geoshards: scala.collection.Seq[String] = geoshardsOrNull,
      source: String = sourceOrNull,
      geoIds: scala.collection.Seq[Long] = geoIdsOrNull,
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = geocodeFeaturesOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull,
      sampleWeight: java.lang.Double = sampleWeightOrNull
  ): GenericScore

  def mutableCopy(): GenericScore.Mutable = {
    val ret = GenericScore.createRawRecord

    if (aggregateByIsSet) ret.aggregateBy_=(aggregateByOrNull)

    if (nameIsSet) ret.name_=(nameOrNull)

    if (scoreIsSet) ret.score_=(scoreOrDefault)

    if (attributeToScoreIsSet) ret.attributeToScore_=(attributeToScoreOrNull)

    if (uidIsSet) ret.uid_=(uidOrDefault)

    if (oidIsSet) ret.oid_=(oidOrNull)

    if (oidsIsSet) ret.oids_=(oidsOrNull)

    if (confidenceIsSet) ret.confidence_=(confidenceOrDefault)

    if (geoshardsIsSet) ret.geoshards_=(geoshardsOrNull)

    if (sourceIsSet) ret.source_=(sourceOrNull)

    if (geoIdsIsSet) ret.geoIds_=(geoIdsOrNull)

    if (geocodeFeaturesIsSet) ret.geocodeFeatures_=(geocodeFeaturesOrNull)

    if (featureIndexIsSet) ret.featureIndex_=(featureIndexOrDefault)

    if (sampleWeightIsSet) ret.sampleWeight_=(sampleWeightOrDefault)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: GenericScore.Mutable

  def toBuilder(): GenericScore.Builder.AllSpecified = {
    val ret = new GenericScore.Builder(GenericScore.createRawRecord)

    if (aggregateByIsSet) ret.aggregateBy(aggregateByOrNull)

    if (nameIsSet) ret.name(nameOrNull)

    if (scoreIsSet) ret.score(scoreOrDefault)

    if (attributeToScoreIsSet) ret.attributeToScore(attributeToScoreOrNull)

    if (uidIsSet) ret.uid(uidOrDefault)

    if (oidIsSet) ret.oid(oidOrNull)

    if (oidsIsSet) ret.oids(oidsOrNull)

    if (confidenceIsSet) ret.confidence(confidenceOrDefault)

    if (geoshardsIsSet) ret.geoshards(geoshardsOrNull)

    if (sourceIsSet) ret.source(sourceOrNull)

    if (geoIdsIsSet) ret.geoIds(geoIdsOrNull)

    if (geocodeFeaturesIsSet) ret.geocodeFeatures(geocodeFeaturesOrNull)

    if (featureIndexIsSet) ret.featureIndex(featureIndexOrDefault)

    if (sampleWeightIsSet) ret.sampleWeight(sampleWeightOrDefault)
    ret
  }

  def mergeCopy(that: GenericScore): GenericScore

}


trait GenericScoreProxy extends GenericScore {
  protected def underlying: GenericScore

  override def meta: GenericScore.type = underlying.meta

// field/proxy_binary.ssp
  override def aggregateByOption: Option[java.nio.ByteBuffer] = underlying.aggregateByOption
  override def aggregateByOrNull: java.nio.ByteBuffer = underlying.aggregateByOrNull
  override def aggregateByOrThrow: java.nio.ByteBuffer = underlying.aggregateByOrThrow
  override def aggregateByIsSet: Boolean = underlying.aggregateByIsSet
  override def aggregateByByteArray: Array[Byte] = underlying.aggregateByByteArray
// field/proxy_ref.ssp
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_primitive.ssp
  override def score: Double = underlying.score
  override def scoreOption: Option[Double] = underlying.scoreOption
  override def scoreOrDefault: Double = underlying.scoreOrDefault
  override def scoreOrNull: java.lang.Double = underlying.scoreOrNull
  override def scoreOrThrow: Double = underlying.scoreOrThrow
  override def scoreIsSet: Boolean = underlying.scoreIsSet
// field/proxy_container.ssp
  override def attributeToScore: scala.collection.immutable.Map[String, Double] = underlying.attributeToScore
  override def attributeToScoreOption: Option[scala.collection.immutable.Map[String, Double]] = underlying.attributeToScoreOption
  override def attributeToScoreOrDefault: scala.collection.immutable.Map[String, Double] = underlying.attributeToScoreOrDefault
  override def attributeToScoreOrNull: scala.collection.immutable.Map[String, Double] = underlying.attributeToScoreOrNull
  override def attributeToScoreOrThrow: scala.collection.immutable.Map[String, Double] = underlying.attributeToScoreOrThrow
  override def attributeToScoreIsSet: Boolean = underlying.attributeToScoreIsSet
// field/proxy_primitive.ssp
  override def uid: Long = underlying.uid
  override def uidOption: Option[Long] = underlying.uidOption
  override def uidOrDefault: Long = underlying.uidOrDefault
  override def uidOrNull: java.lang.Long = underlying.uidOrNull
  override def uidOrThrow: Long = underlying.uidOrThrow
  override def uidIsSet: Boolean = underlying.uidIsSet
// field/proxy_ref.ssp
  override def oidOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.oidOption
  override def oidOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = underlying.oidOrNull
  override def oidOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = underlying.oidOrThrow
  override def oidIsSet: Boolean = underlying.oidIsSet
// field/proxy_container.ssp
  override def oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.oids
  override def oidsOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]] = underlying.oidsOption
  override def oidsOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.oidsOrDefault
  override def oidsOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.oidsOrNull
  override def oidsOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.oidsOrThrow
  override def oidsIsSet: Boolean = underlying.oidsIsSet
// field/proxy_primitive.ssp
  override def confidence: Double = underlying.confidence
  override def confidenceOption: Option[Double] = underlying.confidenceOption
  override def confidenceOrDefault: Double = underlying.confidenceOrDefault
  override def confidenceOrNull: java.lang.Double = underlying.confidenceOrNull
  override def confidenceOrThrow: Double = underlying.confidenceOrThrow
  override def confidenceIsSet: Boolean = underlying.confidenceIsSet
// field/proxy_container.ssp
  override def geoshards: scala.collection.Seq[String] = underlying.geoshards
  override def geoshardsOption: Option[scala.collection.Seq[String]] = underlying.geoshardsOption
  override def geoshardsOrDefault: scala.collection.Seq[String] = underlying.geoshardsOrDefault
  override def geoshardsOrNull: scala.collection.Seq[String] = underlying.geoshardsOrNull
  override def geoshardsOrThrow: scala.collection.Seq[String] = underlying.geoshardsOrThrow
  override def geoshardsIsSet: Boolean = underlying.geoshardsIsSet
// field/proxy_ref.ssp
  override def sourceOption: Option[String] = underlying.sourceOption
  override def sourceOrNull: String = underlying.sourceOrNull
  override def sourceOrThrow: String = underlying.sourceOrThrow
  override def sourceIsSet: Boolean = underlying.sourceIsSet
// field/proxy_container.ssp
  override def geoIds: scala.collection.Seq[Long] = underlying.geoIds
  override def geoIdsOption: Option[scala.collection.Seq[Long]] = underlying.geoIdsOption
  override def geoIdsOrDefault: scala.collection.Seq[Long] = underlying.geoIdsOrDefault
  override def geoIdsOrNull: scala.collection.Seq[Long] = underlying.geoIdsOrNull
  override def geoIdsOrThrow: scala.collection.Seq[Long] = underlying.geoIdsOrThrow
  override def geoIdsIsSet: Boolean = underlying.geoIdsIsSet
// field/proxy_ref.ssp
  override def geocodeFeaturesOption: Option[com.foursquare.twofishes.gen.GeocodeFeatures] = underlying.geocodeFeaturesOption
  override def geocodeFeaturesOrNull: com.foursquare.twofishes.gen.GeocodeFeatures = underlying.geocodeFeaturesOrNull
  override def geocodeFeaturesOrThrow: com.foursquare.twofishes.gen.GeocodeFeatures = underlying.geocodeFeaturesOrThrow
  override def geocodeFeaturesIsSet: Boolean = underlying.geocodeFeaturesIsSet
// field/proxy_primitive.ssp
  override def featureIndex: Int = underlying.featureIndex
  override def featureIndexOption: Option[Int] = underlying.featureIndexOption
  override def featureIndexOrDefault: Int = underlying.featureIndexOrDefault
  override def featureIndexOrNull: java.lang.Integer = underlying.featureIndexOrNull
  override def featureIndexOrThrow: Int = underlying.featureIndexOrThrow
  override def featureIndexIsSet: Boolean = underlying.featureIndexIsSet
// field/proxy_primitive.ssp
  override def sampleWeight: Double = underlying.sampleWeight
  override def sampleWeightOption: Option[Double] = underlying.sampleWeightOption
  override def sampleWeightOrDefault: Double = underlying.sampleWeightOrDefault
  override def sampleWeightOrNull: java.lang.Double = underlying.sampleWeightOrNull
  override def sampleWeightOrThrow: Double = underlying.sampleWeightOrThrow
  override def sampleWeightIsSet: Boolean = underlying.sampleWeightIsSet

  override def compare(that: GenericScore): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      aggregateBy: java.nio.ByteBuffer = aggregateByOrNull,
      name: String = nameOrNull,
      score: java.lang.Double = scoreOrNull,
      attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrNull,
      uid: java.lang.Long = uidOrNull,
      oid: org.bson.types.ObjectId = oidOrNull,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrNull,
      confidence: java.lang.Double = confidenceOrNull,
      geoshards: scala.collection.Seq[String] = geoshardsOrNull,
      source: String = sourceOrNull,
      geoIds: scala.collection.Seq[Long] = geoIdsOrNull,
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = geocodeFeaturesOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull,
      sampleWeight: java.lang.Double = sampleWeightOrNull
  ): GenericScore = underlying.copy(
    aggregateBy = aggregateBy,
    name = name,
    score = score,
    attributeToScore = attributeToScore,
    uid = uid,
    oid = oid,
    oids = oids,
    confidence = confidence,
    geoshards = geoshards,
    source = source,
    geoIds = geoIds,
    geocodeFeatures = geocodeFeatures,
    featureIndex = featureIndex,
    sampleWeight = sampleWeight
  )

  override def mutableCopy(): GenericScore.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: GenericScore): GenericScore = underlying.mergeCopy(that)

  override def mutable: GenericScore.Mutable = underlying.mutable

  override def deepCopy(): GenericScore = underlying.deepCopy()

  override def fieldForId(id: Int): GenericScore._Fields = underlying.fieldForId(id)
  override def isSet(field: GenericScore._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: GenericScore._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: GenericScore._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableGenericScore extends GenericScore {
  def aggregateBy_=(x: java.nio.ByteBuffer): Unit
  def aggregateByUnset(): Unit
  def aggregateByByteArray_=(x: Array[Byte]): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def score_=(x: Double): Unit
  def scoreUnset(): Unit
  def attributeToScore_=(x: scala.collection.immutable.Map[String, Double]): Unit
  def attributeToScoreUnset(): Unit
  def uid_=(x: Long): Unit
  def uidUnset(): Unit
  def oid_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit
  def oidUnset(): Unit
  def oids_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): Unit
  def oidsUnset(): Unit
  def confidence_=(x: Double): Unit
  def confidenceUnset(): Unit
  def geoshards_=(x: scala.collection.Seq[String]): Unit
  def geoshardsUnset(): Unit
  def source_=(x: String): Unit
  def sourceUnset(): Unit
  def geoIds_=(x: scala.collection.Seq[Long]): Unit
  def geoIdsUnset(): Unit
  def geocodeFeatures_=(x: com.foursquare.twofishes.gen.GeocodeFeatures): Unit
  def geocodeFeaturesUnset(): Unit
  def featureIndex_=(x: Int): Unit
  def featureIndexUnset(): Unit
  def sampleWeight_=(x: Double): Unit
  def sampleWeightUnset(): Unit

  def merge(that: GenericScore): Unit

  def copy(
      aggregateBy: java.nio.ByteBuffer = aggregateByOrNull,
      name: String = nameOrNull,
      score: java.lang.Double = scoreOrNull,
      attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrNull,
      uid: java.lang.Long = uidOrNull,
      oid: org.bson.types.ObjectId = oidOrNull,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrNull,
      confidence: java.lang.Double = confidenceOrNull,
      geoshards: scala.collection.Seq[String] = geoshardsOrNull,
      source: String = sourceOrNull,
      geoIds: scala.collection.Seq[Long] = geoIdsOrNull,
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = geocodeFeaturesOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull,
      sampleWeight: java.lang.Double = sampleWeightOrNull
  ): GenericScore.Mutable

  override def mutable: GenericScore.Mutable = this
}

trait MutableGenericScoreProxy extends MutableGenericScore with GenericScoreProxy {
  protected def underlying: MutableGenericScore

  override def aggregateBy_=(x: java.nio.ByteBuffer): Unit = { underlying.aggregateBy_=(x) }
  override def aggregateByUnset(): Unit = { underlying.aggregateByUnset() }
  override def aggregateByByteArray_=(x: Array[Byte]): Unit = { underlying.aggregateByByteArray_=(x) }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def score_=(x: Double): Unit = { underlying.score_=(x) }
  override def scoreUnset(): Unit = { underlying.scoreUnset() }
  override def attributeToScore_=(x: scala.collection.immutable.Map[String, Double]): Unit = { underlying.attributeToScore_=(x) }
  override def attributeToScoreUnset(): Unit = { underlying.attributeToScoreUnset() }
  override def uid_=(x: Long): Unit = { underlying.uid_=(x) }
  override def uidUnset(): Unit = { underlying.uidUnset() }
  override def oid_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit = { underlying.oid_=(x) }
  override def oidUnset(): Unit = { underlying.oidUnset() }
  override def oids_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): Unit = { underlying.oids_=(x) }
  override def oidsUnset(): Unit = { underlying.oidsUnset() }
  override def confidence_=(x: Double): Unit = { underlying.confidence_=(x) }
  override def confidenceUnset(): Unit = { underlying.confidenceUnset() }
  override def geoshards_=(x: scala.collection.Seq[String]): Unit = { underlying.geoshards_=(x) }
  override def geoshardsUnset(): Unit = { underlying.geoshardsUnset() }
  override def source_=(x: String): Unit = { underlying.source_=(x) }
  override def sourceUnset(): Unit = { underlying.sourceUnset() }
  override def geoIds_=(x: scala.collection.Seq[Long]): Unit = { underlying.geoIds_=(x) }
  override def geoIdsUnset(): Unit = { underlying.geoIdsUnset() }
  override def geocodeFeatures_=(x: com.foursquare.twofishes.gen.GeocodeFeatures): Unit = { underlying.geocodeFeatures_=(x) }
  override def geocodeFeaturesUnset(): Unit = { underlying.geocodeFeaturesUnset() }
  override def featureIndex_=(x: Int): Unit = { underlying.featureIndex_=(x) }
  override def featureIndexUnset(): Unit = { underlying.featureIndexUnset() }
  override def sampleWeight_=(x: Double): Unit = { underlying.sampleWeight_=(x) }
  override def sampleWeightUnset(): Unit = { underlying.sampleWeightUnset() }

  override def copy(
      aggregateBy: java.nio.ByteBuffer = aggregateByOrNull,
      name: String = nameOrNull,
      score: java.lang.Double = scoreOrNull,
      attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrNull,
      uid: java.lang.Long = uidOrNull,
      oid: org.bson.types.ObjectId = oidOrNull,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrNull,
      confidence: java.lang.Double = confidenceOrNull,
      geoshards: scala.collection.Seq[String] = geoshardsOrNull,
      source: String = sourceOrNull,
      geoIds: scala.collection.Seq[Long] = geoIdsOrNull,
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = geocodeFeaturesOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull,
      sampleWeight: java.lang.Double = sampleWeightOrNull
  ): GenericScore.Mutable = underlying.copy(
    aggregateBy = aggregateBy,
    name = name,
    score = score,
    attributeToScore = attributeToScore,
    uid = uid,
    oid = oid,
    oids = oids,
    confidence = confidence,
    geoshards = geoshards,
    source = source,
    geoIds = geoIds,
    geocodeFeatures = geocodeFeatures,
    featureIndex = featureIndex,
    sampleWeight = sampleWeight
  )

  override def merge(that: GenericScore): Unit = underlying.merge(that)
}



final class RawGenericScore extends MutableGenericScore {
  override def meta: GenericScore.type = GenericScore

  // Field #1 - aggregateBy
  private var _aggregateBy: java.nio.ByteBuffer = null  // Underlying type: java.nio.ByteBuffer
  override def aggregateBy_=(x: java.nio.ByteBuffer): Unit = { _aggregateBy = x }
  override def aggregateByOption: Option[java.nio.ByteBuffer] = if (aggregateByIsSet) Some(_aggregateBy) else None
  override def aggregateByOrNull: java.nio.ByteBuffer = _aggregateBy
  override def aggregateByOrThrow: java.nio.ByteBuffer = if (aggregateByIsSet) _aggregateBy else throw new java.lang.NullPointerException
  override def aggregateByIsSet: Boolean = _aggregateBy != null
  override def aggregateByUnset(): Unit = { _aggregateBy = null }
  override def aggregateByByteArray: Array[Byte] = { _aggregateBy = org.apache.thrift.TBaseHelper.rightSize(_aggregateBy); _aggregateBy.array }
  override def aggregateByByteArray_=(x: Array[Byte]): Unit = { _aggregateBy = java.nio.ByteBuffer.wrap(x) }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #3 - score
  private var _score: Double = 0.0  // Underlying type: Double
  private var _scoreIsSet: Boolean = false
  override def score: Double = scoreOrDefault
  override def score_=(x: Double): Unit = { _score = x ; _scoreIsSet = true }
  override def scoreOption: Option[Double] = if (scoreIsSet) Some(_score) else None
  override def scoreOrDefault: Double = _score
  override def scoreOrNull: java.lang.Double = if (scoreIsSet) _score else null
  override def scoreOrThrow: Double = if (scoreIsSet) _score else throw new java.lang.NullPointerException
  override def scoreIsSet: Boolean = _scoreIsSet
  override def scoreUnset(): Unit = { _scoreIsSet = false; _score = 0.0 }
  // Field #4 - attributeToScore
  private var _attributeToScore: scala.collection.immutable.Map[String, Double] = null  // Underlying type: scala.collection.immutable.Map[String, Double]
  override def attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrDefault
  override def attributeToScore_=(x: scala.collection.immutable.Map[String, Double]): Unit = { _attributeToScore = x }
  override def attributeToScoreOption: Option[scala.collection.immutable.Map[String, Double]] = if (attributeToScoreIsSet) Some(_attributeToScore) else None
  override def attributeToScoreOrDefault: scala.collection.immutable.Map[String, Double] = if (attributeToScoreIsSet) _attributeToScore else scala.collection.immutable.Map.empty
  override def attributeToScoreOrNull: scala.collection.immutable.Map[String, Double] = _attributeToScore
  override def attributeToScoreOrThrow: scala.collection.immutable.Map[String, Double] = if (attributeToScoreIsSet) _attributeToScore else throw new java.lang.NullPointerException
  override def attributeToScoreIsSet: Boolean = _attributeToScore != null
  override def attributeToScoreUnset(): Unit = { _attributeToScore = null }
  // Field #5 - uid
  private var _uid: Long = 0L  // Underlying type: Long
  private var _uidIsSet: Boolean = false
  override def uid: Long = uidOrDefault
  override def uid_=(x: Long): Unit = { _uid = x ; _uidIsSet = true }
  override def uidOption: Option[Long] = if (uidIsSet) Some(_uid) else None
  override def uidOrDefault: Long = _uid
  override def uidOrNull: java.lang.Long = if (uidIsSet) _uid else null
  override def uidOrThrow: Long = if (uidIsSet) _uid else throw new java.lang.NullPointerException
  override def uidIsSet: Boolean = _uidIsSet
  override def uidUnset(): Unit = { _uidIsSet = false; _uid = 0L }
  // Field #6 - oid
  private var _oid: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = null  // Underlying type: java.nio.ByteBuffer
  override def oid_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit = { _oid = x }
  override def oidOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = if (oidIsSet) Some(_oid) else None
  override def oidOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = _oid
  override def oidOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = if (oidIsSet) _oid else throw new java.lang.NullPointerException
  override def oidIsSet: Boolean = _oid != null
  override def oidUnset(): Unit = { _oid = null }
  // Field #7 - oids
  private var _oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = null  // Underlying type: scala.collection.Seq[java.nio.ByteBuffer]
  override def oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrDefault
  override def oids_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): Unit = { _oids = x }
  override def oidsOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]] = if (oidsIsSet) Some(_oids) else None
  override def oidsOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = if (oidsIsSet) _oids else scala.collection.Seq.empty
  override def oidsOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = _oids
  override def oidsOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = if (oidsIsSet) _oids else throw new java.lang.NullPointerException
  override def oidsIsSet: Boolean = _oids != null
  override def oidsUnset(): Unit = { _oids = null }
  // Field #8 - confidence
  private var _confidence: Double = 0.0  // Underlying type: Double
  private var _confidenceIsSet: Boolean = false
  override def confidence: Double = confidenceOrDefault
  override def confidence_=(x: Double): Unit = { _confidence = x ; _confidenceIsSet = true }
  override def confidenceOption: Option[Double] = if (confidenceIsSet) Some(_confidence) else None
  override def confidenceOrDefault: Double = _confidence
  override def confidenceOrNull: java.lang.Double = if (confidenceIsSet) _confidence else null
  override def confidenceOrThrow: Double = if (confidenceIsSet) _confidence else throw new java.lang.NullPointerException
  override def confidenceIsSet: Boolean = _confidenceIsSet
  override def confidenceUnset(): Unit = { _confidenceIsSet = false; _confidence = 0.0 }
  // Field #9 - geoshards
  private var _geoshards: scala.collection.Seq[String] = null  // Underlying type: scala.collection.Seq[String]
  override def geoshards: scala.collection.Seq[String] = geoshardsOrDefault
  override def geoshards_=(x: scala.collection.Seq[String]): Unit = { _geoshards = x }
  override def geoshardsOption: Option[scala.collection.Seq[String]] = if (geoshardsIsSet) Some(_geoshards) else None
  override def geoshardsOrDefault: scala.collection.Seq[String] = if (geoshardsIsSet) _geoshards else scala.collection.Seq.empty
  override def geoshardsOrNull: scala.collection.Seq[String] = _geoshards
  override def geoshardsOrThrow: scala.collection.Seq[String] = if (geoshardsIsSet) _geoshards else throw new java.lang.NullPointerException
  override def geoshardsIsSet: Boolean = _geoshards != null
  override def geoshardsUnset(): Unit = { _geoshards = null }
  // Field #10 - source
  private var _source: String = null  // Underlying type: String
  override def source_=(x: String): Unit = { _source = x }
  override def sourceOption: Option[String] = if (sourceIsSet) Some(_source) else None
  override def sourceOrNull: String = _source
  override def sourceOrThrow: String = if (sourceIsSet) _source else throw new java.lang.NullPointerException
  override def sourceIsSet: Boolean = _source != null
  override def sourceUnset(): Unit = { _source = null }
  // Field #11 - geoIds
  private var _geoIds: scala.collection.Seq[Long] = null  // Underlying type: scala.collection.Seq[Long]
  override def geoIds: scala.collection.Seq[Long] = geoIdsOrDefault
  override def geoIds_=(x: scala.collection.Seq[Long]): Unit = { _geoIds = x }
  override def geoIdsOption: Option[scala.collection.Seq[Long]] = if (geoIdsIsSet) Some(_geoIds) else None
  override def geoIdsOrDefault: scala.collection.Seq[Long] = if (geoIdsIsSet) _geoIds else scala.collection.Seq.empty
  override def geoIdsOrNull: scala.collection.Seq[Long] = _geoIds
  override def geoIdsOrThrow: scala.collection.Seq[Long] = if (geoIdsIsSet) _geoIds else throw new java.lang.NullPointerException
  override def geoIdsIsSet: Boolean = _geoIds != null
  override def geoIdsUnset(): Unit = { _geoIds = null }
  // Field #12 - geocodeFeatures
  private var _geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = null  // Underlying type: com.foursquare.twofishes.gen.GeocodeFeatures
  override def geocodeFeatures_=(x: com.foursquare.twofishes.gen.GeocodeFeatures): Unit = { _geocodeFeatures = x }
  override def geocodeFeaturesOption: Option[com.foursquare.twofishes.gen.GeocodeFeatures] = if (geocodeFeaturesIsSet) Some(_geocodeFeatures) else None
  override def geocodeFeaturesOrNull: com.foursquare.twofishes.gen.GeocodeFeatures = _geocodeFeatures
  override def geocodeFeaturesOrThrow: com.foursquare.twofishes.gen.GeocodeFeatures = if (geocodeFeaturesIsSet) _geocodeFeatures else throw new java.lang.NullPointerException
  override def geocodeFeaturesIsSet: Boolean = _geocodeFeatures != null
  override def geocodeFeaturesUnset(): Unit = { _geocodeFeatures = null }
  // Field #13 - featureIndex
  private var _featureIndex: Int = 0  // Underlying type: Int
  private var _featureIndexIsSet: Boolean = false
  override def featureIndex: Int = featureIndexOrDefault
  override def featureIndex_=(x: Int): Unit = { _featureIndex = x ; _featureIndexIsSet = true }
  override def featureIndexOption: Option[Int] = if (featureIndexIsSet) Some(_featureIndex) else None
  override def featureIndexOrDefault: Int = _featureIndex
  override def featureIndexOrNull: java.lang.Integer = if (featureIndexIsSet) _featureIndex else null
  override def featureIndexOrThrow: Int = if (featureIndexIsSet) _featureIndex else throw new java.lang.NullPointerException
  override def featureIndexIsSet: Boolean = _featureIndexIsSet
  override def featureIndexUnset(): Unit = { _featureIndexIsSet = false; _featureIndex = 0 }
  // Field #14 - sampleWeight
  private var _sampleWeight: Double = 0.0  // Underlying type: Double
  private var _sampleWeightIsSet: Boolean = false
  override def sampleWeight: Double = sampleWeightOrDefault
  override def sampleWeight_=(x: Double): Unit = { _sampleWeight = x ; _sampleWeightIsSet = true }
  override def sampleWeightOption: Option[Double] = if (sampleWeightIsSet) Some(_sampleWeight) else None
  override def sampleWeightOrDefault: Double = _sampleWeight
  override def sampleWeightOrNull: java.lang.Double = if (sampleWeightIsSet) _sampleWeight else null
  override def sampleWeightOrThrow: Double = if (sampleWeightIsSet) _sampleWeight else throw new java.lang.NullPointerException
  override def sampleWeightIsSet: Boolean = _sampleWeightIsSet
  override def sampleWeightUnset(): Unit = { _sampleWeightIsSet = false; _sampleWeight = 0.0 }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(GenericScore.GENERICSCORE_DESC)
    if (aggregateByIsSet) {
      oprot.writeFieldBegin(GenericScore.AGGREGATEBY_DESC)
      oprot.writeBinary(_aggregateBy)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(GenericScore.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (scoreIsSet) {
      oprot.writeFieldBegin(GenericScore.SCORE_DESC)
      oprot.writeDouble(_score)
      oprot.writeFieldEnd()
    }
    if (attributeToScoreIsSet) {
      oprot.writeFieldBegin(GenericScore.ATTRIBUTETOSCORE_DESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.DOUBLE, _attributeToScore.size))
      _attributeToScore.foreach(item => {
        oprot.writeString(item._1)
        oprot.writeDouble(item._2)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
    if (uidIsSet) {
      oprot.writeFieldBegin(GenericScore.UID_DESC)
      oprot.writeI64(_uid)
      oprot.writeFieldEnd()
    }
    if (oidIsSet) {
      oprot.writeFieldBegin(GenericScore.OID_DESC)
      oprot.writeBinary(java.nio.ByteBuffer.wrap(_oid.toByteArray))
      oprot.writeFieldEnd()
    }
    if (oidsIsSet) {
      oprot.writeFieldBegin(GenericScore.OIDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, _oids.size))
      _oids.foreach(element => {
        oprot.writeBinary(java.nio.ByteBuffer.wrap(element.toByteArray))
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (confidenceIsSet) {
      oprot.writeFieldBegin(GenericScore.CONFIDENCE_DESC)
      oprot.writeDouble(_confidence)
      oprot.writeFieldEnd()
    }
    if (geoshardsIsSet) {
      oprot.writeFieldBegin(GenericScore.GEOSHARDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, _geoshards.size))
      _geoshards.foreach(element => {
        oprot.writeString(element)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (sourceIsSet) {
      oprot.writeFieldBegin(GenericScore.SOURCE_DESC)
      oprot.writeString(_source)
      oprot.writeFieldEnd()
    }
    if (geoIdsIsSet) {
      oprot.writeFieldBegin(GenericScore.GEOIDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I64, _geoIds.size))
      _geoIds.foreach(element => {
        oprot.writeI64(element)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (geocodeFeaturesIsSet) {
      oprot.writeFieldBegin(GenericScore.GEOCODEFEATURES_DESC)
      _geocodeFeatures.write(oprot)
      oprot.writeFieldEnd()
    }
    if (featureIndexIsSet) {
      oprot.writeFieldBegin(GenericScore.FEATUREINDEX_DESC)
      oprot.writeI32(_featureIndex)
      oprot.writeFieldEnd()
    }
    if (sampleWeightIsSet) {
      oprot.writeFieldBegin(GenericScore.SAMPLEWEIGHT_DESC)
      oprot.writeDouble(_sampleWeight)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        GenericScore.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // aggregateBy

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _aggregateBy = iprot.readBinary()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // score

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _score = iprot.readDouble()

              _scoreIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // attributeToScore

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _attributeToScore = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[String, Double]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readString()
                  val v = iprot.readDouble()
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // uid

            if (field_header.`type` == org.apache.thrift.protocol.TType.I64) {
              _uid = iprot.readI64()

              _uidIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 6 => {  // oid

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _oid = new org.bson.types.ObjectId(org.apache.thrift.TBaseHelper.rightSize(iprot.readBinary()).array)
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 7 => {  // oids

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _oids = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += new org.bson.types.ObjectId(org.apache.thrift.TBaseHelper.rightSize(iprot.readBinary()).array)
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 8 => {  // confidence

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _confidence = iprot.readDouble()

              _confidenceIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 9 => {  // geoshards

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _geoshards = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[String]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += iprot.readString()
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 10 => {  // source

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _source = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 11 => {  // geoIds

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _geoIds = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[Long]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += iprot.readI64()
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 12 => {  // geocodeFeatures

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _geocodeFeatures = ({
                val s = com.foursquare.twofishes.gen.GeocodeFeatures.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 13 => {  // featureIndex

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32) {
              _featureIndex = iprot.readI32()

              _featureIndexIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 14 => {  // sampleWeight

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _sampleWeight = iprot.readDouble()

              _sampleWeightIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure GenericScore".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: GenericScore): Unit = {
    if (that.aggregateByIsSet && !this.aggregateByIsSet) {
      this.aggregateBy_=(that.aggregateByOrNull)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.scoreIsSet && !this.scoreIsSet) {
      this.score_=(that.scoreOrDefault)
    }
    if (that.attributeToScoreIsSet && !this.attributeToScoreIsSet) {
      this.attributeToScore_=(that.attributeToScoreOrNull)

    } else if (that.attributeToScoreIsSet && this.attributeToScoreIsSet) {
      this.attributeToScore ++= that.attributeToScore
    }
    if (that.uidIsSet && !this.uidIsSet) {
      this.uid_=(that.uidOrDefault)
    }
    if (that.oidIsSet && !this.oidIsSet) {
      this.oid_=(that.oidOrNull)
    }
    if (that.oidsIsSet && !this.oidsIsSet) {
      this.oids_=(that.oidsOrNull)

    } else if (that.oidsIsSet && this.oidsIsSet) {
      this.oids ++= that.oids
    }
    if (that.confidenceIsSet && !this.confidenceIsSet) {
      this.confidence_=(that.confidenceOrDefault)
    }
    if (that.geoshardsIsSet && !this.geoshardsIsSet) {
      this.geoshards_=(that.geoshardsOrNull)

    } else if (that.geoshardsIsSet && this.geoshardsIsSet) {
      this.geoshards ++= that.geoshards
    }
    if (that.sourceIsSet && !this.sourceIsSet) {
      this.source_=(that.sourceOrNull)
    }
    if (that.geoIdsIsSet && !this.geoIdsIsSet) {
      this.geoIds_=(that.geoIdsOrNull)

    } else if (that.geoIdsIsSet && this.geoIdsIsSet) {
      this.geoIds ++= that.geoIds
    }
    if (that.geocodeFeaturesIsSet && !this.geocodeFeaturesIsSet) {
      this.geocodeFeatures_=(that.geocodeFeaturesOrNull)
    }
    if (that.featureIndexIsSet && !this.featureIndexIsSet) {
      this.featureIndex_=(that.featureIndexOrDefault)
    }
    if (that.sampleWeightIsSet && !this.sampleWeightIsSet) {
      this.sampleWeight_=(that.sampleWeightOrDefault)
    }
  }

  override def mergeCopy(that: GenericScore): GenericScore = {
    val ret = GenericScore.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: GenericScore => this.equals(o)
    case _ => false
  }

  def equals(that: GenericScore): Boolean = {
    that != null &&
    (if (this.aggregateByIsSet) (that.aggregateByIsSet && this.aggregateByOrNull == that.aggregateByOrNull) else !that.aggregateByIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.scoreIsSet) (that.scoreIsSet && this.scoreOrDefault == that.scoreOrDefault) else !that.scoreIsSet) &&
    (if (this.attributeToScoreIsSet) (that.attributeToScoreIsSet && this.attributeToScoreOrNull == that.attributeToScoreOrNull) else !that.attributeToScoreIsSet) &&
    (if (this.uidIsSet) (that.uidIsSet && this.uidOrDefault == that.uidOrDefault) else !that.uidIsSet) &&
    (if (this.oidIsSet) (that.oidIsSet && this.oidOrNull == that.oidOrNull) else !that.oidIsSet) &&
    (if (this.oidsIsSet) (that.oidsIsSet && this.oidsOrNull == that.oidsOrNull) else !that.oidsIsSet) &&
    (if (this.confidenceIsSet) (that.confidenceIsSet && this.confidenceOrDefault == that.confidenceOrDefault) else !that.confidenceIsSet) &&
    (if (this.geoshardsIsSet) (that.geoshardsIsSet && this.geoshardsOrNull == that.geoshardsOrNull) else !that.geoshardsIsSet) &&
    (if (this.sourceIsSet) (that.sourceIsSet && this.sourceOrNull == that.sourceOrNull) else !that.sourceIsSet) &&
    (if (this.geoIdsIsSet) (that.geoIdsIsSet && this.geoIdsOrNull == that.geoIdsOrNull) else !that.geoIdsIsSet) &&
    (if (this.geocodeFeaturesIsSet) (that.geocodeFeaturesIsSet && this.geocodeFeaturesOrNull == that.geocodeFeaturesOrNull) else !that.geocodeFeaturesIsSet) &&
    (if (this.featureIndexIsSet) (that.featureIndexIsSet && this.featureIndexOrDefault == that.featureIndexOrDefault) else !that.featureIndexIsSet) &&
    (if (this.sampleWeightIsSet) (that.sampleWeightIsSet && this.sampleWeightOrDefault == that.sampleWeightOrDefault) else !that.sampleWeightIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (aggregateByIsSet) hasher.append(_aggregateBy.##)
    if (nameIsSet) hasher.append(_name.##)
    if (scoreIsSet) hasher.append(_score.##)
    if (attributeToScoreIsSet) hasher.append(_attributeToScore.##)
    if (uidIsSet) hasher.append(_uid.##)
    if (oidIsSet) hasher.append(_oid.##)
    if (oidsIsSet) hasher.append(_oids.##)
    if (confidenceIsSet) hasher.append(_confidence.##)
    if (geoshardsIsSet) hasher.append(_geoshards.##)
    if (sourceIsSet) hasher.append(_source.##)
    if (geoIdsIsSet) hasher.append(_geoIds.##)
    if (geocodeFeaturesIsSet) hasher.append(_geocodeFeatures.##)
    if (featureIndexIsSet) hasher.append(_featureIndex.##)
    if (sampleWeightIsSet) hasher.append(_sampleWeight.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (aggregateByIsSet) ret = aggregateByOrNull :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    if (scoreIsSet) ret = scoreOrDefault :: ret
    if (attributeToScoreIsSet) ret = attributeToScoreOrNull :: ret
    if (uidIsSet) ret = uidOrDefault :: ret
    if (oidIsSet) ret = oidOrNull :: ret
    if (oidsIsSet) ret = oidsOrNull :: ret
    if (confidenceIsSet) ret = confidenceOrDefault :: ret
    if (geoshardsIsSet) ret = geoshardsOrNull :: ret
    if (sourceIsSet) ret = sourceOrNull :: ret
    if (geoIdsIsSet) ret = geoIdsOrNull :: ret
    if (geocodeFeaturesIsSet) ret = geocodeFeaturesOrNull :: ret
    if (featureIndexIsSet) ret = featureIndexOrDefault :: ret
    if (sampleWeightIsSet) ret = sampleWeightOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    aggregateByUnset()
    nameUnset()
    scoreUnset()
    attributeToScoreUnset()
    uidUnset()
    oidUnset()
    oidsUnset()
    confidenceUnset()
    geoshardsUnset()
    sourceUnset()
    geoIdsUnset()
    geocodeFeaturesUnset()
    featureIndexUnset()
    sampleWeightUnset()
  }

  def fieldForId(id: Int): GenericScore._Fields = id match {
    case 1 => GenericScore._Fields.aggregateBy
    case 2 => GenericScore._Fields.name
    case 3 => GenericScore._Fields.score
    case 4 => GenericScore._Fields.attributeToScore
    case 5 => GenericScore._Fields.uid
    case 6 => GenericScore._Fields.oid
    case 7 => GenericScore._Fields.oids
    case 8 => GenericScore._Fields.confidence
    case 9 => GenericScore._Fields.geoshards
    case 10 => GenericScore._Fields.source
    case 11 => GenericScore._Fields.geoIds
    case 12 => GenericScore._Fields.geocodeFeatures
    case 13 => GenericScore._Fields.featureIndex
    case 14 => GenericScore._Fields.sampleWeight
    case _ => null
  }

  def isSet(field: GenericScore._Fields): Boolean = field match {
    case GenericScore._Fields.aggregateBy => aggregateByIsSet
    case GenericScore._Fields.name => nameIsSet
    case GenericScore._Fields.score => scoreIsSet
    case GenericScore._Fields.attributeToScore => attributeToScoreIsSet
    case GenericScore._Fields.uid => uidIsSet
    case GenericScore._Fields.oid => oidIsSet
    case GenericScore._Fields.oids => oidsIsSet
    case GenericScore._Fields.confidence => confidenceIsSet
    case GenericScore._Fields.geoshards => geoshardsIsSet
    case GenericScore._Fields.source => sourceIsSet
    case GenericScore._Fields.geoIds => geoIdsIsSet
    case GenericScore._Fields.geocodeFeatures => geocodeFeaturesIsSet
    case GenericScore._Fields.featureIndex => featureIndexIsSet
    case GenericScore._Fields.sampleWeight => sampleWeightIsSet
    case _ => false
  }

  def getFieldValue(field: GenericScore._Fields): AnyRef = field match {
    case GenericScore._Fields.aggregateBy => aggregateByOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.score => scoreOrDefault.asInstanceOf[AnyRef]
    case GenericScore._Fields.attributeToScore => attributeToScoreOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.uid => uidOrDefault.asInstanceOf[AnyRef]
    case GenericScore._Fields.oid => oidOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.oids => oidsOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.confidence => confidenceOrDefault.asInstanceOf[AnyRef]
    case GenericScore._Fields.geoshards => geoshardsOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.source => sourceOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.geoIds => geoIdsOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.geocodeFeatures => geocodeFeaturesOrNull.asInstanceOf[AnyRef]
    case GenericScore._Fields.featureIndex => featureIndexOrDefault.asInstanceOf[AnyRef]
    case GenericScore._Fields.sampleWeight => sampleWeightOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: GenericScore._Fields, value: AnyRef) {
    field match {
      case GenericScore._Fields.aggregateBy => aggregateBy_=(value.asInstanceOf[java.nio.ByteBuffer])
      case GenericScore._Fields.name => name_=(value.asInstanceOf[String])
      case GenericScore._Fields.score => score_=(value.asInstanceOf[Double])
      case GenericScore._Fields.attributeToScore => attributeToScore_=(value.asInstanceOf[scala.collection.immutable.Map[String, Double]])
      case GenericScore._Fields.uid => uid_=(value.asInstanceOf[Long])
      case GenericScore._Fields.oid => oid_=(value.asInstanceOf[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId])
      case GenericScore._Fields.oids => oids_=(value.asInstanceOf[scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]])
      case GenericScore._Fields.confidence => confidence_=(value.asInstanceOf[Double])
      case GenericScore._Fields.geoshards => geoshards_=(value.asInstanceOf[scala.collection.Seq[String]])
      case GenericScore._Fields.source => source_=(value.asInstanceOf[String])
      case GenericScore._Fields.geoIds => geoIds_=(value.asInstanceOf[scala.collection.Seq[Long]])
      case GenericScore._Fields.geocodeFeatures => geocodeFeatures_=(value.asInstanceOf[com.foursquare.twofishes.gen.GeocodeFeatures])
      case GenericScore._Fields.featureIndex => featureIndex_=(value.asInstanceOf[Int])
      case GenericScore._Fields.sampleWeight => sampleWeight_=(value.asInstanceOf[Double])
      case _ =>
    }
  }

  override def deepCopy(): GenericScore.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = GenericScore.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      aggregateBy: java.nio.ByteBuffer = aggregateByOrNull,
      name: String = nameOrNull,
      score: java.lang.Double = scoreOrNull,
      attributeToScore: scala.collection.immutable.Map[String, Double] = attributeToScoreOrNull,
      uid: java.lang.Long = uidOrNull,
      oid: org.bson.types.ObjectId = oidOrNull,
      oids: scala.collection.Seq[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = oidsOrNull,
      confidence: java.lang.Double = confidenceOrNull,
      geoshards: scala.collection.Seq[String] = geoshardsOrNull,
      source: String = sourceOrNull,
      geoIds: scala.collection.Seq[Long] = geoIdsOrNull,
      geocodeFeatures: com.foursquare.twofishes.gen.GeocodeFeatures = geocodeFeaturesOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull,
      sampleWeight: java.lang.Double = sampleWeightOrNull
  ): GenericScore.Raw = {
    val ret = new GenericScore.Raw
    if (aggregateBy != null) ret.aggregateBy_=(aggregateBy)
    if (name != null) ret.name_=(name)
    if (score != null) ret.score_=(score)
    if (attributeToScore != null) ret.attributeToScore_=(attributeToScore)
    if (uid != null) ret.uid_=(uid)
    if (oid != null) ret.oid_=(oid)
    if (oids != null) ret.oids_=(oids)
    if (confidence != null) ret.confidence_=(confidence)
    if (geoshards != null) ret.geoshards_=(geoshards)
    if (source != null) ret.source_=(source)
    if (geoIds != null) ret.geoIds_=(geoIds)
    if (geocodeFeatures != null) ret.geocodeFeatures_=(geocodeFeatures)
    if (featureIndex != null) ret.featureIndex_=(featureIndex)
    if (sampleWeight != null) ret.sampleWeight_=(sampleWeight)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object GenericScoreList
    extends com.foursquare.spindle.MetaRecord[GenericScoreList]
    with com.foursquare.spindle.RecordProvider[GenericScoreList] {
  override def recordName: String = "GenericScoreList"


  // Thrift descriptors.
  val GENERICSCORELIST_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("GenericScoreList")

  val SCORES_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "scores",
      org.apache.thrift.protocol.TType.LIST,
      1,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "scores" -> SCORES_DESC
  )

  object _Fields {
    case object scores extends _Fields(1, "scores")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.scores
  )

  // Record v2
  override type Self = GenericScoreList.type
  override type Trait = GenericScoreList
  override type Mutable = MutableGenericScoreList
  override type Raw = RawGenericScoreList

  override def createRecord: GenericScoreList = createRawRecord
  override def createRawRecord: GenericScoreList.Raw = new GenericScoreList.Raw

  override def ifInstanceFrom(x: AnyRef): Option[GenericScoreList] = {
    if (x.isInstanceOf[GenericScoreList]) Some(x.asInstanceOf[GenericScoreList]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val scores =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.foursquare.math.gen.GenericScore], GenericScoreList, GenericScoreList.type](
      name = "scores",
      longName = "scores",
      id = 1,
      annotations = Map(),
      owner = GenericScoreList,
      getter = _.scoresOption,
      setterRaw = (r: GenericScoreList.Raw, v: scala.collection.Seq[com.foursquare.math.gen.GenericScore]) => { r.scores_=(v) },
      manifest = manifest[scala.collection.Seq[com.foursquare.math.gen.GenericScore]]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, GenericScoreList, GenericScoreList.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, GenericScoreList, GenericScoreList.type]](
      scores
    )


  def apply(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  ): GenericScoreList = {
    val ret = GenericScoreList.createRawRecord
    ret.scores_=(scores)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[GenericScoreList] (private var obj: GenericScoreList.Raw) {

    def scores(v: scala.collection.Seq[com.foursquare.math.gen.GenericScore]): GenericScoreList.Builder[State] = {
      obj.scores_=(v)
      this
    }

    def scores(vOpt: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScore]]): GenericScoreList.Builder[State] = {
      vOpt match {
        case Some(v) => obj.scores_=(v)
        case None => obj.scoresUnset()
      }
      this
    }

    def resultMutable()(): GenericScoreList.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("GenericScoreList.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): GenericScoreList = resultMutable()()
  }

  def newBuilder: GenericScoreList.Builder.AllUnspecified = new Builder(GenericScoreList.createRawRecord)

  implicit val companionProvider: GenericScoreListCompanionProvider = new GenericScoreListCompanionProvider
}

class GenericScoreListCompanionProvider extends com.foursquare.spindle.CompanionProvider[GenericScoreList] {
  type CompanionT = GenericScoreList.type
  override def provide: GenericScoreList.type = GenericScoreList
}



trait GenericScoreList

    extends com.foursquare.spindle.Record[GenericScoreList]
    with scala.Ordered[GenericScoreList]
    with org.apache.thrift.TBase[GenericScoreList, GenericScoreList._Fields] {

  override type MetaT = GenericScoreList.type

  def scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  def scoresOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScore]]
  def scoresOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  def scoresOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  def scoresOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  def scoresIsSet: Boolean
  override def compare(that: GenericScoreList): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.scoresIsSet.compareTo(that.scoresIsSet)
      cmp != 0 }) cmp
    else if (this.scoresIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.scores.asJava, that.scores.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): GenericScoreList

  def copy(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrNull
  ): GenericScoreList

  def mutableCopy(): GenericScoreList.Mutable = {
    val ret = GenericScoreList.createRawRecord

    if (scoresIsSet) ret.scores_=(scoresOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: GenericScoreList.Mutable

  def toBuilder(): GenericScoreList.Builder.AllSpecified = {
    val ret = new GenericScoreList.Builder(GenericScoreList.createRawRecord)

    if (scoresIsSet) ret.scores(scoresOrNull)
    ret
  }

  def mergeCopy(that: GenericScoreList): GenericScoreList

}


trait GenericScoreListProxy extends GenericScoreList {
  protected def underlying: GenericScoreList

  override def meta: GenericScoreList.type = underlying.meta

// field/proxy_container.ssp
  override def scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = underlying.scores
  override def scoresOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScore]] = underlying.scoresOption
  override def scoresOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = underlying.scoresOrDefault
  override def scoresOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = underlying.scoresOrNull
  override def scoresOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = underlying.scoresOrThrow
  override def scoresIsSet: Boolean = underlying.scoresIsSet

  override def compare(that: GenericScoreList): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrNull
  ): GenericScoreList = underlying.copy(
    scores = scores
  )

  override def mutableCopy(): GenericScoreList.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: GenericScoreList): GenericScoreList = underlying.mergeCopy(that)

  override def mutable: GenericScoreList.Mutable = underlying.mutable

  override def deepCopy(): GenericScoreList = underlying.deepCopy()

  override def fieldForId(id: Int): GenericScoreList._Fields = underlying.fieldForId(id)
  override def isSet(field: GenericScoreList._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: GenericScoreList._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: GenericScoreList._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableGenericScoreList extends GenericScoreList {
  def scores_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScore]): Unit
  def scoresUnset(): Unit

  def merge(that: GenericScoreList): Unit

  def copy(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrNull
  ): GenericScoreList.Mutable

  override def mutable: GenericScoreList.Mutable = this
}

trait MutableGenericScoreListProxy extends MutableGenericScoreList with GenericScoreListProxy {
  protected def underlying: MutableGenericScoreList

  override def scores_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScore]): Unit = { underlying.scores_=(x) }
  override def scoresUnset(): Unit = { underlying.scoresUnset() }

  override def copy(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrNull
  ): GenericScoreList.Mutable = underlying.copy(
    scores = scores
  )

  override def merge(that: GenericScoreList): Unit = underlying.merge(that)
}



final class RawGenericScoreList extends MutableGenericScoreList {
  override def meta: GenericScoreList.type = GenericScoreList

  // Field #1 - scores
  private var _scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = null  // Underlying type: scala.collection.Seq[com.foursquare.math.gen.GenericScore]
  override def scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrDefault
  override def scores_=(x: scala.collection.Seq[com.foursquare.math.gen.GenericScore]): Unit = { _scores = x }
  override def scoresOption: Option[scala.collection.Seq[com.foursquare.math.gen.GenericScore]] = if (scoresIsSet) Some(_scores) else None
  override def scoresOrDefault: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = if (scoresIsSet) _scores else scala.collection.Seq.empty
  override def scoresOrNull: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = _scores
  override def scoresOrThrow: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = if (scoresIsSet) _scores else throw new java.lang.NullPointerException
  override def scoresIsSet: Boolean = _scores != null
  override def scoresUnset(): Unit = { _scores = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(GenericScoreList.GENERICSCORELIST_DESC)
    if (scoresIsSet) {
      oprot.writeFieldBegin(GenericScoreList.SCORES_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _scores.size))
      _scores.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        GenericScoreList.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // scores

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _scores = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.foursquare.math.gen.GenericScore]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.foursquare.math.gen.GenericScore.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure GenericScoreList".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: GenericScoreList): Unit = {
    if (that.scoresIsSet && !this.scoresIsSet) {
      this.scores_=(that.scoresOrNull)

    } else if (that.scoresIsSet && this.scoresIsSet) {
      this.scores ++= that.scores
    }
  }

  override def mergeCopy(that: GenericScoreList): GenericScoreList = {
    val ret = GenericScoreList.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: GenericScoreList => this.equals(o)
    case _ => false
  }

  def equals(that: GenericScoreList): Boolean = {
    that != null &&
    (if (this.scoresIsSet) (that.scoresIsSet && this.scoresOrNull == that.scoresOrNull) else !that.scoresIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (scoresIsSet) hasher.append(_scores.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (scoresIsSet) ret = scoresOrNull :: ret
    ret.reverse
  }

  override def clear() {
    scoresUnset()
  }

  def fieldForId(id: Int): GenericScoreList._Fields = id match {
    case 1 => GenericScoreList._Fields.scores
    case _ => null
  }

  def isSet(field: GenericScoreList._Fields): Boolean = field match {
    case GenericScoreList._Fields.scores => scoresIsSet
    case _ => false
  }

  def getFieldValue(field: GenericScoreList._Fields): AnyRef = field match {
    case GenericScoreList._Fields.scores => scoresOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: GenericScoreList._Fields, value: AnyRef) {
    field match {
      case GenericScoreList._Fields.scores => scores_=(value.asInstanceOf[scala.collection.Seq[com.foursquare.math.gen.GenericScore]])
      case _ =>
    }
  }

  override def deepCopy(): GenericScoreList.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = GenericScoreList.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      scores: scala.collection.Seq[com.foursquare.math.gen.GenericScore] = scoresOrNull
  ): GenericScoreList.Raw = {
    val ret = new GenericScoreList.Raw
    if (scores != null) ret.scores_=(scores)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object GenericStatisticsKey
    extends com.foursquare.spindle.MetaRecord[GenericStatisticsKey]
    with com.foursquare.spindle.RecordProvider[GenericStatisticsKey] {
  override def recordName: String = "GenericStatisticsKey"


  // Thrift descriptors.
  val GENERICSTATISTICSKEY_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("GenericStatisticsKey")

  val ATTRIBUTE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "attribute",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val CATEGORY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "category",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]("bson" -> "ObjectId").asJava
    )
  val GEOID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "geoId",
      org.apache.thrift.protocol.TType.I64,
      3,
      Map[String, String]().asJava
    )
  val FEATUREINDEX_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "featureIndex",
      org.apache.thrift.protocol.TType.I32,
      4,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "attribute" -> ATTRIBUTE_DESC,
    "category" -> CATEGORY_DESC,
    "geoId" -> GEOID_DESC,
    "featureIndex" -> FEATUREINDEX_DESC
  )

  object _Fields {
    case object attribute extends _Fields(1, "attribute")
    case object category extends _Fields(2, "category")
    case object geoId extends _Fields(3, "geoId")
    case object featureIndex extends _Fields(4, "featureIndex")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.attribute,
    2.toShort -> _Fields.category,
    3.toShort -> _Fields.geoId,
    4.toShort -> _Fields.featureIndex
  )

  // Record v2
  override type Self = GenericStatisticsKey.type
  override type Trait = GenericStatisticsKey
  override type Mutable = MutableGenericStatisticsKey
  override type Raw = RawGenericStatisticsKey

  override def createRecord: GenericStatisticsKey = createRawRecord
  override def createRawRecord: GenericStatisticsKey.Raw = new GenericStatisticsKey.Raw

  override def ifInstanceFrom(x: AnyRef): Option[GenericStatisticsKey] = {
    if (x.isInstanceOf[GenericStatisticsKey]) Some(x.asInstanceOf[GenericStatisticsKey]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val attribute =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, GenericStatisticsKey, GenericStatisticsKey.type](
      name = "attribute",
      longName = "attribute",
      id = 1,
      annotations = Map(),
      owner = GenericStatisticsKey,
      getter = _.attributeOption,
      setterRaw = (r: GenericStatisticsKey.Raw, v: String) => { r.attribute_=(v) },
      manifest = manifest[String]
    )

  val category =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId, GenericStatisticsKey, GenericStatisticsKey.type](
      name = "category",
      longName = "category",
      id = 2,
      annotations = Map(),
      owner = GenericStatisticsKey,
      getter = _.categoryOption,
      setterRaw = (r: GenericStatisticsKey.Raw, v: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId) => { r.category_=(v) },
      manifest = manifest[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
    )

  val geoId =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId, GenericStatisticsKey, GenericStatisticsKey.type](
      name = "geoId",
      longName = "geoId",
      id = 3,
      annotations = Map(),
      owner = GenericStatisticsKey,
      getter = _.geoIdOption,
      setterRaw = (r: GenericStatisticsKey.Raw, v: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId) => { r.geoId_=(v) },
      manifest = manifest[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId]
    )

  val featureIndex =

    new com.foursquare.spindle.OptionalFieldDescriptor[Int, GenericStatisticsKey, GenericStatisticsKey.type](
      name = "featureIndex",
      longName = "featureIndex",
      id = 4,
      annotations = Map(),
      owner = GenericStatisticsKey,
      getter = _.featureIndexOption,
      setterRaw = (r: GenericStatisticsKey.Raw, v: Int) => { r.featureIndex_=(v) },
      manifest = manifest[Int]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, GenericStatisticsKey, GenericStatisticsKey.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, GenericStatisticsKey, GenericStatisticsKey.type]](
      attribute,
      category,
      geoId,
      featureIndex
    )


  def apply(
      attribute: String,
      category: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId,
      geoId: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId,
      featureIndex: Int
  ): GenericStatisticsKey = {
    val ret = GenericStatisticsKey.createRawRecord
    ret.attribute_=(attribute)
    ret.category_=(category)
    ret.geoId_=(geoId)
    ret.featureIndex_=(featureIndex)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[GenericStatisticsKey] (private var obj: GenericStatisticsKey.Raw) {

    def attribute(v: String): GenericStatisticsKey.Builder[State] = {
      obj.attribute_=(v)
      this
    }

    def attribute(vOpt: Option[String]): GenericStatisticsKey.Builder[State] = {
      vOpt match {
        case Some(v) => obj.attribute_=(v)
        case None => obj.attributeUnset()
      }
      this
    }

    def category(v: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): GenericStatisticsKey.Builder[State] = {
      obj.category_=(v)
      this
    }

    def category(vOpt: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]): GenericStatisticsKey.Builder[State] = {
      vOpt match {
        case Some(v) => obj.category_=(v)
        case None => obj.categoryUnset()
      }
      this
    }

    def geoId(v: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId): GenericStatisticsKey.Builder[State] = {
      obj.geoId_=(v)
      this
    }

    def geoId(vOpt: Option[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId]): GenericStatisticsKey.Builder[State] = {
      vOpt match {
        case Some(v) => obj.geoId_=(v)
        case None => obj.geoIdUnset()
      }
      this
    }

    def featureIndex(v: Int): GenericStatisticsKey.Builder[State] = {
      obj.featureIndex_=(v)
      this
    }

    def featureIndex(vOpt: Option[Int]): GenericStatisticsKey.Builder[State] = {
      vOpt match {
        case Some(v) => obj.featureIndex_=(v)
        case None => obj.featureIndexUnset()
      }
      this
    }

    def resultMutable()(): GenericStatisticsKey.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("GenericStatisticsKey.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): GenericStatisticsKey = resultMutable()()
  }

  def newBuilder: GenericStatisticsKey.Builder.AllUnspecified = new Builder(GenericStatisticsKey.createRawRecord)

  implicit val companionProvider: GenericStatisticsKeyCompanionProvider = new GenericStatisticsKeyCompanionProvider
}

class GenericStatisticsKeyCompanionProvider extends com.foursquare.spindle.CompanionProvider[GenericStatisticsKey] {
  type CompanionT = GenericStatisticsKey.type
  override def provide: GenericStatisticsKey.type = GenericStatisticsKey
}



trait GenericStatisticsKey

    extends com.foursquare.spindle.Record[GenericStatisticsKey]
    with scala.Ordered[GenericStatisticsKey]
    with org.apache.thrift.TBase[GenericStatisticsKey, GenericStatisticsKey._Fields] {

  override type MetaT = GenericStatisticsKey.type

  def attributeOption: Option[String]
  def attributeOrNull: String
  def attributeOrThrow: String
  def attributeIsSet: Boolean
  def categoryOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId]
  def categoryOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId
  def categoryOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId
  def categoryIsSet: Boolean
  def geoId: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId
  def geoIdOption: Option[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId]
  def geoIdOrDefault: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId
  def geoIdOrNull: java.lang.Long
  def geoIdOrThrow: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId
  def geoIdIsSet: Boolean
  def featureIndex: Int
  def featureIndexOption: Option[Int]
  def featureIndexOrDefault: Int
  def featureIndexOrNull: java.lang.Integer
  def featureIndexOrThrow: Int
  def featureIndexIsSet: Boolean
  override def compare(that: GenericStatisticsKey): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.attributeIsSet.compareTo(that.attributeIsSet)
      cmp != 0 }) cmp
    else if (this.attributeIsSet && {
      cmp = this.attributeOrNull.compareTo(that.attributeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.categoryIsSet.compareTo(that.categoryIsSet)
      cmp != 0 }) cmp
    else if (this.categoryIsSet && {
      cmp = this.categoryOrNull.compareTo(that.categoryOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.geoIdIsSet.compareTo(that.geoIdIsSet)
      cmp != 0 }) cmp
    else if (this.geoIdIsSet && {
      cmp = this.geoId.compareTo(that.geoId)
      cmp != 0 }) cmp
    else if ({
      cmp = this.featureIndexIsSet.compareTo(that.featureIndexIsSet)
      cmp != 0 }) cmp
    else if (this.featureIndexIsSet && {
      cmp = this.featureIndex.compareTo(that.featureIndex)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): GenericStatisticsKey

  def copy(
      attribute: String = attributeOrNull,
      category: org.bson.types.ObjectId = categoryOrNull,
      geoId: java.lang.Long = geoIdOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull
  ): GenericStatisticsKey

  def mutableCopy(): GenericStatisticsKey.Mutable = {
    val ret = GenericStatisticsKey.createRawRecord

    if (attributeIsSet) ret.attribute_=(attributeOrNull)

    if (categoryIsSet) ret.category_=(categoryOrNull)

    if (geoIdIsSet) ret.geoId_=(geoIdOrDefault)

    if (featureIndexIsSet) ret.featureIndex_=(featureIndexOrDefault)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: GenericStatisticsKey.Mutable

  def toBuilder(): GenericStatisticsKey.Builder.AllSpecified = {
    val ret = new GenericStatisticsKey.Builder(GenericStatisticsKey.createRawRecord)

    if (attributeIsSet) ret.attribute(attributeOrNull)

    if (categoryIsSet) ret.category(categoryOrNull)

    if (geoIdIsSet) ret.geoId(geoIdOrDefault)

    if (featureIndexIsSet) ret.featureIndex(featureIndexOrDefault)
    ret
  }

  def mergeCopy(that: GenericStatisticsKey): GenericStatisticsKey

}


trait GenericStatisticsKeyProxy extends GenericStatisticsKey {
  protected def underlying: GenericStatisticsKey

  override def meta: GenericStatisticsKey.type = underlying.meta

// field/proxy_ref.ssp
  override def attributeOption: Option[String] = underlying.attributeOption
  override def attributeOrNull: String = underlying.attributeOrNull
  override def attributeOrThrow: String = underlying.attributeOrThrow
  override def attributeIsSet: Boolean = underlying.attributeIsSet
// field/proxy_ref.ssp
  override def categoryOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = underlying.categoryOption
  override def categoryOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = underlying.categoryOrNull
  override def categoryOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = underlying.categoryOrThrow
  override def categoryIsSet: Boolean = underlying.categoryIsSet
// field/proxy_primitive.ssp
  override def geoId: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = underlying.geoId
  override def geoIdOption: Option[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId] = underlying.geoIdOption
  override def geoIdOrDefault: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = underlying.geoIdOrDefault
  override def geoIdOrNull: java.lang.Long = underlying.geoIdOrNull
  override def geoIdOrThrow: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = underlying.geoIdOrThrow
  override def geoIdIsSet: Boolean = underlying.geoIdIsSet
// field/proxy_primitive.ssp
  override def featureIndex: Int = underlying.featureIndex
  override def featureIndexOption: Option[Int] = underlying.featureIndexOption
  override def featureIndexOrDefault: Int = underlying.featureIndexOrDefault
  override def featureIndexOrNull: java.lang.Integer = underlying.featureIndexOrNull
  override def featureIndexOrThrow: Int = underlying.featureIndexOrThrow
  override def featureIndexIsSet: Boolean = underlying.featureIndexIsSet

  override def compare(that: GenericStatisticsKey): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      attribute: String = attributeOrNull,
      category: org.bson.types.ObjectId = categoryOrNull,
      geoId: java.lang.Long = geoIdOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull
  ): GenericStatisticsKey = underlying.copy(
    attribute = attribute,
    category = category,
    geoId = geoId,
    featureIndex = featureIndex
  )

  override def mutableCopy(): GenericStatisticsKey.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: GenericStatisticsKey): GenericStatisticsKey = underlying.mergeCopy(that)

  override def mutable: GenericStatisticsKey.Mutable = underlying.mutable

  override def deepCopy(): GenericStatisticsKey = underlying.deepCopy()

  override def fieldForId(id: Int): GenericStatisticsKey._Fields = underlying.fieldForId(id)
  override def isSet(field: GenericStatisticsKey._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: GenericStatisticsKey._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: GenericStatisticsKey._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableGenericStatisticsKey extends GenericStatisticsKey {
  def attribute_=(x: String): Unit
  def attributeUnset(): Unit
  def category_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit
  def categoryUnset(): Unit
  def geoId_=(x: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId): Unit
  def geoIdUnset(): Unit
  def featureIndex_=(x: Int): Unit
  def featureIndexUnset(): Unit

  def merge(that: GenericStatisticsKey): Unit

  def copy(
      attribute: String = attributeOrNull,
      category: org.bson.types.ObjectId = categoryOrNull,
      geoId: java.lang.Long = geoIdOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull
  ): GenericStatisticsKey.Mutable

  override def mutable: GenericStatisticsKey.Mutable = this
}

trait MutableGenericStatisticsKeyProxy extends MutableGenericStatisticsKey with GenericStatisticsKeyProxy {
  protected def underlying: MutableGenericStatisticsKey

  override def attribute_=(x: String): Unit = { underlying.attribute_=(x) }
  override def attributeUnset(): Unit = { underlying.attributeUnset() }
  override def category_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit = { underlying.category_=(x) }
  override def categoryUnset(): Unit = { underlying.categoryUnset() }
  override def geoId_=(x: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId): Unit = { underlying.geoId_=(x) }
  override def geoIdUnset(): Unit = { underlying.geoIdUnset() }
  override def featureIndex_=(x: Int): Unit = { underlying.featureIndex_=(x) }
  override def featureIndexUnset(): Unit = { underlying.featureIndexUnset() }

  override def copy(
      attribute: String = attributeOrNull,
      category: org.bson.types.ObjectId = categoryOrNull,
      geoId: java.lang.Long = geoIdOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull
  ): GenericStatisticsKey.Mutable = underlying.copy(
    attribute = attribute,
    category = category,
    geoId = geoId,
    featureIndex = featureIndex
  )

  override def merge(that: GenericStatisticsKey): Unit = underlying.merge(that)
}



final class RawGenericStatisticsKey extends MutableGenericStatisticsKey {
  override def meta: GenericStatisticsKey.type = GenericStatisticsKey

  // Field #1 - attribute
  private var _attribute: String = null  // Underlying type: String
  override def attribute_=(x: String): Unit = { _attribute = x }
  override def attributeOption: Option[String] = if (attributeIsSet) Some(_attribute) else None
  override def attributeOrNull: String = _attribute
  override def attributeOrThrow: String = if (attributeIsSet) _attribute else throw new java.lang.NullPointerException
  override def attributeIsSet: Boolean = _attribute != null
  override def attributeUnset(): Unit = { _attribute = null }
  // Field #2 - category
  private var _category: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = null  // Underlying type: java.nio.ByteBuffer
  override def category_=(x: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId): Unit = { _category = x }
  override def categoryOption: Option[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId] = if (categoryIsSet) Some(_category) else None
  override def categoryOrNull: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = _category
  override def categoryOrThrow: com.foursquare.math.gen.GenericScoreTypedefs.ObjectId = if (categoryIsSet) _category else throw new java.lang.NullPointerException
  override def categoryIsSet: Boolean = _category != null
  override def categoryUnset(): Unit = { _category = null }
  // Field #3 - geoId
  private var _geoId: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = 0L  // Underlying type: Long
  private var _geoIdIsSet: Boolean = false
  override def geoId: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = geoIdOrDefault
  override def geoId_=(x: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId): Unit = { _geoId = x ; _geoIdIsSet = true }
  override def geoIdOption: Option[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId] = if (geoIdIsSet) Some(_geoId) else None
  override def geoIdOrDefault: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = _geoId
  override def geoIdOrNull: java.lang.Long = if (geoIdIsSet) _geoId else null
  override def geoIdOrThrow: com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId = if (geoIdIsSet) _geoId else throw new java.lang.NullPointerException
  override def geoIdIsSet: Boolean = _geoIdIsSet
  override def geoIdUnset(): Unit = { _geoIdIsSet = false; _geoId = 0L }
  // Field #4 - featureIndex
  private var _featureIndex: Int = 0  // Underlying type: Int
  private var _featureIndexIsSet: Boolean = false
  override def featureIndex: Int = featureIndexOrDefault
  override def featureIndex_=(x: Int): Unit = { _featureIndex = x ; _featureIndexIsSet = true }
  override def featureIndexOption: Option[Int] = if (featureIndexIsSet) Some(_featureIndex) else None
  override def featureIndexOrDefault: Int = _featureIndex
  override def featureIndexOrNull: java.lang.Integer = if (featureIndexIsSet) _featureIndex else null
  override def featureIndexOrThrow: Int = if (featureIndexIsSet) _featureIndex else throw new java.lang.NullPointerException
  override def featureIndexIsSet: Boolean = _featureIndexIsSet
  override def featureIndexUnset(): Unit = { _featureIndexIsSet = false; _featureIndex = 0 }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(GenericStatisticsKey.GENERICSTATISTICSKEY_DESC)
    if (attributeIsSet) {
      oprot.writeFieldBegin(GenericStatisticsKey.ATTRIBUTE_DESC)
      oprot.writeString(_attribute)
      oprot.writeFieldEnd()
    }
    if (categoryIsSet) {
      oprot.writeFieldBegin(GenericStatisticsKey.CATEGORY_DESC)
      oprot.writeBinary(java.nio.ByteBuffer.wrap(_category.toByteArray))
      oprot.writeFieldEnd()
    }
    if (geoIdIsSet) {
      oprot.writeFieldBegin(GenericStatisticsKey.GEOID_DESC)
      oprot.writeI64(_geoId)
      oprot.writeFieldEnd()
    }
    if (featureIndexIsSet) {
      oprot.writeFieldBegin(GenericStatisticsKey.FEATUREINDEX_DESC)
      oprot.writeI32(_featureIndex)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        GenericStatisticsKey.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // attribute

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _attribute = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // category

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _category = new org.bson.types.ObjectId(org.apache.thrift.TBaseHelper.rightSize(iprot.readBinary()).array)
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // geoId

            if (field_header.`type` == org.apache.thrift.protocol.TType.I64) {
              _geoId = iprot.readI64()

              _geoIdIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // featureIndex

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32) {
              _featureIndex = iprot.readI32()

              _featureIndexIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure GenericStatisticsKey".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: GenericStatisticsKey): Unit = {
    if (that.attributeIsSet && !this.attributeIsSet) {
      this.attribute_=(that.attributeOrNull)
    }
    if (that.categoryIsSet && !this.categoryIsSet) {
      this.category_=(that.categoryOrNull)
    }
    if (that.geoIdIsSet && !this.geoIdIsSet) {
      this.geoId_=(that.geoIdOrDefault)
    }
    if (that.featureIndexIsSet && !this.featureIndexIsSet) {
      this.featureIndex_=(that.featureIndexOrDefault)
    }
  }

  override def mergeCopy(that: GenericStatisticsKey): GenericStatisticsKey = {
    val ret = GenericStatisticsKey.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: GenericStatisticsKey => this.equals(o)
    case _ => false
  }

  def equals(that: GenericStatisticsKey): Boolean = {
    that != null &&
    (if (this.attributeIsSet) (that.attributeIsSet && this.attributeOrNull == that.attributeOrNull) else !that.attributeIsSet) &&
    (if (this.categoryIsSet) (that.categoryIsSet && this.categoryOrNull == that.categoryOrNull) else !that.categoryIsSet) &&
    (if (this.geoIdIsSet) (that.geoIdIsSet && this.geoIdOrDefault == that.geoIdOrDefault) else !that.geoIdIsSet) &&
    (if (this.featureIndexIsSet) (that.featureIndexIsSet && this.featureIndexOrDefault == that.featureIndexOrDefault) else !that.featureIndexIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (attributeIsSet) hasher.append(_attribute.##)
    if (categoryIsSet) hasher.append(_category.##)
    if (geoIdIsSet) hasher.append(_geoId.##)
    if (featureIndexIsSet) hasher.append(_featureIndex.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (attributeIsSet) ret = attributeOrNull :: ret
    if (categoryIsSet) ret = categoryOrNull :: ret
    if (geoIdIsSet) ret = geoIdOrDefault :: ret
    if (featureIndexIsSet) ret = featureIndexOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    attributeUnset()
    categoryUnset()
    geoIdUnset()
    featureIndexUnset()
  }

  def fieldForId(id: Int): GenericStatisticsKey._Fields = id match {
    case 1 => GenericStatisticsKey._Fields.attribute
    case 2 => GenericStatisticsKey._Fields.category
    case 3 => GenericStatisticsKey._Fields.geoId
    case 4 => GenericStatisticsKey._Fields.featureIndex
    case _ => null
  }

  def isSet(field: GenericStatisticsKey._Fields): Boolean = field match {
    case GenericStatisticsKey._Fields.attribute => attributeIsSet
    case GenericStatisticsKey._Fields.category => categoryIsSet
    case GenericStatisticsKey._Fields.geoId => geoIdIsSet
    case GenericStatisticsKey._Fields.featureIndex => featureIndexIsSet
    case _ => false
  }

  def getFieldValue(field: GenericStatisticsKey._Fields): AnyRef = field match {
    case GenericStatisticsKey._Fields.attribute => attributeOrNull.asInstanceOf[AnyRef]
    case GenericStatisticsKey._Fields.category => categoryOrNull.asInstanceOf[AnyRef]
    case GenericStatisticsKey._Fields.geoId => geoIdOrDefault.asInstanceOf[AnyRef]
    case GenericStatisticsKey._Fields.featureIndex => featureIndexOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: GenericStatisticsKey._Fields, value: AnyRef) {
    field match {
      case GenericStatisticsKey._Fields.attribute => attribute_=(value.asInstanceOf[String])
      case GenericStatisticsKey._Fields.category => category_=(value.asInstanceOf[com.foursquare.math.gen.GenericScoreTypedefs.ObjectId])
      case GenericStatisticsKey._Fields.geoId => geoId_=(value.asInstanceOf[com.foursquare.twofishes.gen.GeocoderTypedefs.GeocodeFeatureLongId])
      case GenericStatisticsKey._Fields.featureIndex => featureIndex_=(value.asInstanceOf[Int])
      case _ =>
    }
  }

  override def deepCopy(): GenericStatisticsKey.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = GenericStatisticsKey.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      attribute: String = attributeOrNull,
      category: org.bson.types.ObjectId = categoryOrNull,
      geoId: java.lang.Long = geoIdOrNull,
      featureIndex: java.lang.Integer = featureIndexOrNull
  ): GenericStatisticsKey.Raw = {
    val ret = new GenericStatisticsKey.Raw
    if (attribute != null) ret.attribute_=(attribute)
    if (category != null) ret.category_=(category)
    if (geoId != null) ret.geoId_=(geoId)
    if (featureIndex != null) ret.featureIndex_=(featureIndex)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object BucketScorePair
    extends com.foursquare.spindle.MetaRecord[BucketScorePair]
    with com.foursquare.spindle.RecordProvider[BucketScorePair] {
  override def recordName: String = "BucketScorePair"


  // Thrift descriptors.
  val BUCKETSCOREPAIR_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("BucketScorePair")

  val BUCKET_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "bucket",
      org.apache.thrift.protocol.TType.I64,
      1,
      Map[String, String]().asJava
    )
  val PERCENTILERANK_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "percentileRank",
      org.apache.thrift.protocol.TType.DOUBLE,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "bucket" -> BUCKET_DESC,
    "percentileRank" -> PERCENTILERANK_DESC
  )

  object _Fields {
    case object bucket extends _Fields(1, "bucket")
    case object percentileRank extends _Fields(2, "percentileRank")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.bucket,
    2.toShort -> _Fields.percentileRank
  )

  // Record v2
  override type Self = BucketScorePair.type
  override type Trait = BucketScorePair
  override type Mutable = MutableBucketScorePair
  override type Raw = RawBucketScorePair

  override def createRecord: BucketScorePair = createRawRecord
  override def createRawRecord: BucketScorePair.Raw = new BucketScorePair.Raw

  override def ifInstanceFrom(x: AnyRef): Option[BucketScorePair] = {
    if (x.isInstanceOf[BucketScorePair]) Some(x.asInstanceOf[BucketScorePair]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val bucket =

    new com.foursquare.spindle.OptionalFieldDescriptor[Long, BucketScorePair, BucketScorePair.type](
      name = "bucket",
      longName = "bucket",
      id = 1,
      annotations = Map(),
      owner = BucketScorePair,
      getter = _.bucketOption,
      setterRaw = (r: BucketScorePair.Raw, v: Long) => { r.bucket_=(v) },
      manifest = manifest[Long]
    )

  val percentileRank =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, BucketScorePair, BucketScorePair.type](
      name = "percentileRank",
      longName = "percentileRank",
      id = 2,
      annotations = Map(),
      owner = BucketScorePair,
      getter = _.percentileRankOption,
      setterRaw = (r: BucketScorePair.Raw, v: Double) => { r.percentileRank_=(v) },
      manifest = manifest[Double]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, BucketScorePair, BucketScorePair.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, BucketScorePair, BucketScorePair.type]](
      bucket,
      percentileRank
    )


  def apply(
      bucket: Long,
      percentileRank: Double
  ): BucketScorePair = {
    val ret = BucketScorePair.createRawRecord
    ret.bucket_=(bucket)
    ret.percentileRank_=(percentileRank)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[BucketScorePair] (private var obj: BucketScorePair.Raw) {

    def bucket(v: Long): BucketScorePair.Builder[State] = {
      obj.bucket_=(v)
      this
    }

    def bucket(vOpt: Option[Long]): BucketScorePair.Builder[State] = {
      vOpt match {
        case Some(v) => obj.bucket_=(v)
        case None => obj.bucketUnset()
      }
      this
    }

    def percentileRank(v: Double): BucketScorePair.Builder[State] = {
      obj.percentileRank_=(v)
      this
    }

    def percentileRank(vOpt: Option[Double]): BucketScorePair.Builder[State] = {
      vOpt match {
        case Some(v) => obj.percentileRank_=(v)
        case None => obj.percentileRankUnset()
      }
      this
    }

    def resultMutable()(): BucketScorePair.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("BucketScorePair.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): BucketScorePair = resultMutable()()
  }

  def newBuilder: BucketScorePair.Builder.AllUnspecified = new Builder(BucketScorePair.createRawRecord)

  implicit val companionProvider: BucketScorePairCompanionProvider = new BucketScorePairCompanionProvider
}

class BucketScorePairCompanionProvider extends com.foursquare.spindle.CompanionProvider[BucketScorePair] {
  type CompanionT = BucketScorePair.type
  override def provide: BucketScorePair.type = BucketScorePair
}



trait BucketScorePair

    extends com.foursquare.spindle.Record[BucketScorePair]
    with scala.Ordered[BucketScorePair]
    with org.apache.thrift.TBase[BucketScorePair, BucketScorePair._Fields] {

  override type MetaT = BucketScorePair.type

  def bucket: Long
  def bucketOption: Option[Long]
  def bucketOrDefault: Long
  def bucketOrNull: java.lang.Long
  def bucketOrThrow: Long
  def bucketIsSet: Boolean
  def percentileRank: Double
  def percentileRankOption: Option[Double]
  def percentileRankOrDefault: Double
  def percentileRankOrNull: java.lang.Double
  def percentileRankOrThrow: Double
  def percentileRankIsSet: Boolean
  override def compare(that: BucketScorePair): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.bucketIsSet.compareTo(that.bucketIsSet)
      cmp != 0 }) cmp
    else if (this.bucketIsSet && {
      cmp = this.bucket.compareTo(that.bucket)
      cmp != 0 }) cmp
    else if ({
      cmp = this.percentileRankIsSet.compareTo(that.percentileRankIsSet)
      cmp != 0 }) cmp
    else if (this.percentileRankIsSet && {
      cmp = this.percentileRank.compareTo(that.percentileRank)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): BucketScorePair

  def copy(
      bucket: java.lang.Long = bucketOrNull,
      percentileRank: java.lang.Double = percentileRankOrNull
  ): BucketScorePair

  def mutableCopy(): BucketScorePair.Mutable = {
    val ret = BucketScorePair.createRawRecord

    if (bucketIsSet) ret.bucket_=(bucketOrDefault)

    if (percentileRankIsSet) ret.percentileRank_=(percentileRankOrDefault)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: BucketScorePair.Mutable

  def toBuilder(): BucketScorePair.Builder.AllSpecified = {
    val ret = new BucketScorePair.Builder(BucketScorePair.createRawRecord)

    if (bucketIsSet) ret.bucket(bucketOrDefault)

    if (percentileRankIsSet) ret.percentileRank(percentileRankOrDefault)
    ret
  }

  def mergeCopy(that: BucketScorePair): BucketScorePair

}


trait BucketScorePairProxy extends BucketScorePair {
  protected def underlying: BucketScorePair

  override def meta: BucketScorePair.type = underlying.meta

// field/proxy_primitive.ssp
  override def bucket: Long = underlying.bucket
  override def bucketOption: Option[Long] = underlying.bucketOption
  override def bucketOrDefault: Long = underlying.bucketOrDefault
  override def bucketOrNull: java.lang.Long = underlying.bucketOrNull
  override def bucketOrThrow: Long = underlying.bucketOrThrow
  override def bucketIsSet: Boolean = underlying.bucketIsSet
// field/proxy_primitive.ssp
  override def percentileRank: Double = underlying.percentileRank
  override def percentileRankOption: Option[Double] = underlying.percentileRankOption
  override def percentileRankOrDefault: Double = underlying.percentileRankOrDefault
  override def percentileRankOrNull: java.lang.Double = underlying.percentileRankOrNull
  override def percentileRankOrThrow: Double = underlying.percentileRankOrThrow
  override def percentileRankIsSet: Boolean = underlying.percentileRankIsSet

  override def compare(that: BucketScorePair): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      bucket: java.lang.Long = bucketOrNull,
      percentileRank: java.lang.Double = percentileRankOrNull
  ): BucketScorePair = underlying.copy(
    bucket = bucket,
    percentileRank = percentileRank
  )

  override def mutableCopy(): BucketScorePair.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: BucketScorePair): BucketScorePair = underlying.mergeCopy(that)

  override def mutable: BucketScorePair.Mutable = underlying.mutable

  override def deepCopy(): BucketScorePair = underlying.deepCopy()

  override def fieldForId(id: Int): BucketScorePair._Fields = underlying.fieldForId(id)
  override def isSet(field: BucketScorePair._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: BucketScorePair._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: BucketScorePair._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableBucketScorePair extends BucketScorePair {
  def bucket_=(x: Long): Unit
  def bucketUnset(): Unit
  def percentileRank_=(x: Double): Unit
  def percentileRankUnset(): Unit

  def merge(that: BucketScorePair): Unit

  def copy(
      bucket: java.lang.Long = bucketOrNull,
      percentileRank: java.lang.Double = percentileRankOrNull
  ): BucketScorePair.Mutable

  override def mutable: BucketScorePair.Mutable = this
}

trait MutableBucketScorePairProxy extends MutableBucketScorePair with BucketScorePairProxy {
  protected def underlying: MutableBucketScorePair

  override def bucket_=(x: Long): Unit = { underlying.bucket_=(x) }
  override def bucketUnset(): Unit = { underlying.bucketUnset() }
  override def percentileRank_=(x: Double): Unit = { underlying.percentileRank_=(x) }
  override def percentileRankUnset(): Unit = { underlying.percentileRankUnset() }

  override def copy(
      bucket: java.lang.Long = bucketOrNull,
      percentileRank: java.lang.Double = percentileRankOrNull
  ): BucketScorePair.Mutable = underlying.copy(
    bucket = bucket,
    percentileRank = percentileRank
  )

  override def merge(that: BucketScorePair): Unit = underlying.merge(that)
}



final class RawBucketScorePair extends MutableBucketScorePair {
  override def meta: BucketScorePair.type = BucketScorePair

  // Field #1 - bucket
  private var _bucket: Long = 0L  // Underlying type: Long
  private var _bucketIsSet: Boolean = false
  override def bucket: Long = bucketOrDefault
  override def bucket_=(x: Long): Unit = { _bucket = x ; _bucketIsSet = true }
  override def bucketOption: Option[Long] = if (bucketIsSet) Some(_bucket) else None
  override def bucketOrDefault: Long = _bucket
  override def bucketOrNull: java.lang.Long = if (bucketIsSet) _bucket else null
  override def bucketOrThrow: Long = if (bucketIsSet) _bucket else throw new java.lang.NullPointerException
  override def bucketIsSet: Boolean = _bucketIsSet
  override def bucketUnset(): Unit = { _bucketIsSet = false; _bucket = 0L }
  // Field #2 - percentileRank
  private var _percentileRank: Double = 0.0  // Underlying type: Double
  private var _percentileRankIsSet: Boolean = false
  override def percentileRank: Double = percentileRankOrDefault
  override def percentileRank_=(x: Double): Unit = { _percentileRank = x ; _percentileRankIsSet = true }
  override def percentileRankOption: Option[Double] = if (percentileRankIsSet) Some(_percentileRank) else None
  override def percentileRankOrDefault: Double = _percentileRank
  override def percentileRankOrNull: java.lang.Double = if (percentileRankIsSet) _percentileRank else null
  override def percentileRankOrThrow: Double = if (percentileRankIsSet) _percentileRank else throw new java.lang.NullPointerException
  override def percentileRankIsSet: Boolean = _percentileRankIsSet
  override def percentileRankUnset(): Unit = { _percentileRankIsSet = false; _percentileRank = 0.0 }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(BucketScorePair.BUCKETSCOREPAIR_DESC)
    if (bucketIsSet) {
      oprot.writeFieldBegin(BucketScorePair.BUCKET_DESC)
      oprot.writeI64(_bucket)
      oprot.writeFieldEnd()
    }
    if (percentileRankIsSet) {
      oprot.writeFieldBegin(BucketScorePair.PERCENTILERANK_DESC)
      oprot.writeDouble(_percentileRank)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        BucketScorePair.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // bucket

            if (field_header.`type` == org.apache.thrift.protocol.TType.I64) {
              _bucket = iprot.readI64()

              _bucketIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // percentileRank

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _percentileRank = iprot.readDouble()

              _percentileRankIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure BucketScorePair".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: BucketScorePair): Unit = {
    if (that.bucketIsSet && !this.bucketIsSet) {
      this.bucket_=(that.bucketOrDefault)
    }
    if (that.percentileRankIsSet && !this.percentileRankIsSet) {
      this.percentileRank_=(that.percentileRankOrDefault)
    }
  }

  override def mergeCopy(that: BucketScorePair): BucketScorePair = {
    val ret = BucketScorePair.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: BucketScorePair => this.equals(o)
    case _ => false
  }

  def equals(that: BucketScorePair): Boolean = {
    that != null &&
    (if (this.bucketIsSet) (that.bucketIsSet && this.bucketOrDefault == that.bucketOrDefault) else !that.bucketIsSet) &&
    (if (this.percentileRankIsSet) (that.percentileRankIsSet && this.percentileRankOrDefault == that.percentileRankOrDefault) else !that.percentileRankIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (bucketIsSet) hasher.append(_bucket.##)
    if (percentileRankIsSet) hasher.append(_percentileRank.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (bucketIsSet) ret = bucketOrDefault :: ret
    if (percentileRankIsSet) ret = percentileRankOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    bucketUnset()
    percentileRankUnset()
  }

  def fieldForId(id: Int): BucketScorePair._Fields = id match {
    case 1 => BucketScorePair._Fields.bucket
    case 2 => BucketScorePair._Fields.percentileRank
    case _ => null
  }

  def isSet(field: BucketScorePair._Fields): Boolean = field match {
    case BucketScorePair._Fields.bucket => bucketIsSet
    case BucketScorePair._Fields.percentileRank => percentileRankIsSet
    case _ => false
  }

  def getFieldValue(field: BucketScorePair._Fields): AnyRef = field match {
    case BucketScorePair._Fields.bucket => bucketOrDefault.asInstanceOf[AnyRef]
    case BucketScorePair._Fields.percentileRank => percentileRankOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: BucketScorePair._Fields, value: AnyRef) {
    field match {
      case BucketScorePair._Fields.bucket => bucket_=(value.asInstanceOf[Long])
      case BucketScorePair._Fields.percentileRank => percentileRank_=(value.asInstanceOf[Double])
      case _ =>
    }
  }

  override def deepCopy(): BucketScorePair.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = BucketScorePair.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      bucket: java.lang.Long = bucketOrNull,
      percentileRank: java.lang.Double = percentileRankOrNull
  ): BucketScorePair.Raw = {
    val ret = new BucketScorePair.Raw
    if (bucket != null) ret.bucket_=(bucket)
    if (percentileRank != null) ret.percentileRank_=(percentileRank)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object GenericStatistics
    extends com.foursquare.spindle.MetaRecord[GenericStatistics]
    with com.foursquare.spindle.RecordProvider[GenericStatistics] {
  override def recordName: String = "GenericStatistics"


  // Thrift descriptors.
  val GENERICSTATISTICS_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("GenericStatistics")

  val COUNT_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "count",
      org.apache.thrift.protocol.TType.I64,
      1,
      Map[String, String]().asJava
    )
  val MEAN_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "mean",
      org.apache.thrift.protocol.TType.DOUBLE,
      2,
      Map[String, String]().asJava
    )
  val STDDEV_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "stdDev",
      org.apache.thrift.protocol.TType.DOUBLE,
      3,
      Map[String, String]().asJava
    )
  val SUM_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "sum",
      org.apache.thrift.protocol.TType.DOUBLE,
      4,
      Map[String, String]().asJava
    )
  val SUMSQUARED_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "sumSquared",
      org.apache.thrift.protocol.TType.DOUBLE,
      5,
      Map[String, String]().asJava
    )
  val INCREMENT_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "increment",
      org.apache.thrift.protocol.TType.DOUBLE,
      6,
      Map[String, String]().asJava
    )
  val BUCKETTOFREQUENCY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "bucketToFrequency",
      org.apache.thrift.protocol.TType.MAP,
      7,
      Map[String, String]().asJava
    )
  val BUCKETTOPERCENTILERANK_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "bucketToPercentileRank",
      org.apache.thrift.protocol.TType.LIST,
      8,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "count" -> COUNT_DESC,
    "mean" -> MEAN_DESC,
    "stdDev" -> STDDEV_DESC,
    "sum" -> SUM_DESC,
    "sumSquared" -> SUMSQUARED_DESC,
    "increment" -> INCREMENT_DESC,
    "bucketToFrequency" -> BUCKETTOFREQUENCY_DESC,
    "bucketToPercentileRank" -> BUCKETTOPERCENTILERANK_DESC
  )

  object _Fields {
    case object count extends _Fields(1, "count")
    case object mean extends _Fields(2, "mean")
    case object stdDev extends _Fields(3, "stdDev")
    case object sum extends _Fields(4, "sum")
    case object sumSquared extends _Fields(5, "sumSquared")
    case object increment extends _Fields(6, "increment")
    case object bucketToFrequency extends _Fields(7, "bucketToFrequency")
    case object bucketToPercentileRank extends _Fields(8, "bucketToPercentileRank")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.count,
    2.toShort -> _Fields.mean,
    3.toShort -> _Fields.stdDev,
    4.toShort -> _Fields.sum,
    5.toShort -> _Fields.sumSquared,
    6.toShort -> _Fields.increment,
    7.toShort -> _Fields.bucketToFrequency,
    8.toShort -> _Fields.bucketToPercentileRank
  )

  // Record v2
  override type Self = GenericStatistics.type
  override type Trait = GenericStatistics
  override type Mutable = MutableGenericStatistics
  override type Raw = RawGenericStatistics

  override def createRecord: GenericStatistics = createRawRecord
  override def createRawRecord: GenericStatistics.Raw = new GenericStatistics.Raw

  override def ifInstanceFrom(x: AnyRef): Option[GenericStatistics] = {
    if (x.isInstanceOf[GenericStatistics]) Some(x.asInstanceOf[GenericStatistics]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val count =

    new com.foursquare.spindle.OptionalFieldDescriptor[Long, GenericStatistics, GenericStatistics.type](
      name = "count",
      longName = "count",
      id = 1,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.countOption,
      setterRaw = (r: GenericStatistics.Raw, v: Long) => { r.count_=(v) },
      manifest = manifest[Long]
    )

  val mean =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericStatistics, GenericStatistics.type](
      name = "mean",
      longName = "mean",
      id = 2,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.meanOption,
      setterRaw = (r: GenericStatistics.Raw, v: Double) => { r.mean_=(v) },
      manifest = manifest[Double]
    )

  val stdDev =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericStatistics, GenericStatistics.type](
      name = "stdDev",
      longName = "stdDev",
      id = 3,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.stdDevOption,
      setterRaw = (r: GenericStatistics.Raw, v: Double) => { r.stdDev_=(v) },
      manifest = manifest[Double]
    )

  val sum =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericStatistics, GenericStatistics.type](
      name = "sum",
      longName = "sum",
      id = 4,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.sumOption,
      setterRaw = (r: GenericStatistics.Raw, v: Double) => { r.sum_=(v) },
      manifest = manifest[Double]
    )

  val sumSquared =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericStatistics, GenericStatistics.type](
      name = "sumSquared",
      longName = "sumSquared",
      id = 5,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.sumSquaredOption,
      setterRaw = (r: GenericStatistics.Raw, v: Double) => { r.sumSquared_=(v) },
      manifest = manifest[Double]
    )

  val increment =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, GenericStatistics, GenericStatistics.type](
      name = "increment",
      longName = "increment",
      id = 6,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.incrementOption,
      setterRaw = (r: GenericStatistics.Raw, v: Double) => { r.increment_=(v) },
      manifest = manifest[Double]
    )

  val bucketToFrequency =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.immutable.Map[Long, Int], GenericStatistics, GenericStatistics.type](
      name = "bucketToFrequency",
      longName = "bucketToFrequency",
      id = 7,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.bucketToFrequencyOption,
      setterRaw = (r: GenericStatistics.Raw, v: scala.collection.immutable.Map[Long, Int]) => { r.bucketToFrequency_=(v) },
      manifest = manifest[scala.collection.immutable.Map[Long, Int]]
    )

  val bucketToPercentileRank =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair], GenericStatistics, GenericStatistics.type](
      name = "bucketToPercentileRank",
      longName = "bucketToPercentileRank",
      id = 8,
      annotations = Map(),
      owner = GenericStatistics,
      getter = _.bucketToPercentileRankOption,
      setterRaw = (r: GenericStatistics.Raw, v: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]) => { r.bucketToPercentileRank_=(v) },
      manifest = manifest[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, GenericStatistics, GenericStatistics.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, GenericStatistics, GenericStatistics.type]](
      count,
      mean,
      stdDev,
      sum,
      sumSquared,
      increment,
      bucketToFrequency,
      bucketToPercentileRank
    )


  def apply(
      count: Long,
      mean: Double,
      stdDev: Double,
      sum: Double,
      sumSquared: Double,
      increment: Double,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int],
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  ): GenericStatistics = {
    val ret = GenericStatistics.createRawRecord
    ret.count_=(count)
    ret.mean_=(mean)
    ret.stdDev_=(stdDev)
    ret.sum_=(sum)
    ret.sumSquared_=(sumSquared)
    ret.increment_=(increment)
    ret.bucketToFrequency_=(bucketToFrequency)
    ret.bucketToPercentileRank_=(bucketToPercentileRank)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[GenericStatistics] (private var obj: GenericStatistics.Raw) {

    def count(v: Long): GenericStatistics.Builder[State] = {
      obj.count_=(v)
      this
    }

    def count(vOpt: Option[Long]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.count_=(v)
        case None => obj.countUnset()
      }
      this
    }

    def mean(v: Double): GenericStatistics.Builder[State] = {
      obj.mean_=(v)
      this
    }

    def mean(vOpt: Option[Double]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.mean_=(v)
        case None => obj.meanUnset()
      }
      this
    }

    def stdDev(v: Double): GenericStatistics.Builder[State] = {
      obj.stdDev_=(v)
      this
    }

    def stdDev(vOpt: Option[Double]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.stdDev_=(v)
        case None => obj.stdDevUnset()
      }
      this
    }

    def sum(v: Double): GenericStatistics.Builder[State] = {
      obj.sum_=(v)
      this
    }

    def sum(vOpt: Option[Double]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.sum_=(v)
        case None => obj.sumUnset()
      }
      this
    }

    def sumSquared(v: Double): GenericStatistics.Builder[State] = {
      obj.sumSquared_=(v)
      this
    }

    def sumSquared(vOpt: Option[Double]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.sumSquared_=(v)
        case None => obj.sumSquaredUnset()
      }
      this
    }

    def increment(v: Double): GenericStatistics.Builder[State] = {
      obj.increment_=(v)
      this
    }

    def increment(vOpt: Option[Double]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.increment_=(v)
        case None => obj.incrementUnset()
      }
      this
    }

    def bucketToFrequency(v: scala.collection.immutable.Map[Long, Int]): GenericStatistics.Builder[State] = {
      obj.bucketToFrequency_=(v)
      this
    }

    def bucketToFrequency(vOpt: Option[scala.collection.immutable.Map[Long, Int]]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.bucketToFrequency_=(v)
        case None => obj.bucketToFrequencyUnset()
      }
      this
    }

    def bucketToPercentileRank(v: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]): GenericStatistics.Builder[State] = {
      obj.bucketToPercentileRank_=(v)
      this
    }

    def bucketToPercentileRank(vOpt: Option[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]]): GenericStatistics.Builder[State] = {
      vOpt match {
        case Some(v) => obj.bucketToPercentileRank_=(v)
        case None => obj.bucketToPercentileRankUnset()
      }
      this
    }

    def resultMutable()(): GenericStatistics.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("GenericStatistics.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): GenericStatistics = resultMutable()()
  }

  def newBuilder: GenericStatistics.Builder.AllUnspecified = new Builder(GenericStatistics.createRawRecord)

  implicit val companionProvider: GenericStatisticsCompanionProvider = new GenericStatisticsCompanionProvider
}

class GenericStatisticsCompanionProvider extends com.foursquare.spindle.CompanionProvider[GenericStatistics] {
  type CompanionT = GenericStatistics.type
  override def provide: GenericStatistics.type = GenericStatistics
}



trait GenericStatistics

    extends com.foursquare.spindle.Record[GenericStatistics]
    with scala.Ordered[GenericStatistics]
    with org.apache.thrift.TBase[GenericStatistics, GenericStatistics._Fields] {

  override type MetaT = GenericStatistics.type

  def count: Long
  def countOption: Option[Long]
  def countOrDefault: Long
  def countOrNull: java.lang.Long
  def countOrThrow: Long
  def countIsSet: Boolean
  def mean: Double
  def meanOption: Option[Double]
  def meanOrDefault: Double
  def meanOrNull: java.lang.Double
  def meanOrThrow: Double
  def meanIsSet: Boolean
  def stdDev: Double
  def stdDevOption: Option[Double]
  def stdDevOrDefault: Double
  def stdDevOrNull: java.lang.Double
  def stdDevOrThrow: Double
  def stdDevIsSet: Boolean
  def sum: Double
  def sumOption: Option[Double]
  def sumOrDefault: Double
  def sumOrNull: java.lang.Double
  def sumOrThrow: Double
  def sumIsSet: Boolean
  def sumSquared: Double
  def sumSquaredOption: Option[Double]
  def sumSquaredOrDefault: Double
  def sumSquaredOrNull: java.lang.Double
  def sumSquaredOrThrow: Double
  def sumSquaredIsSet: Boolean
  def increment: Double
  def incrementOption: Option[Double]
  def incrementOrDefault: Double
  def incrementOrNull: java.lang.Double
  def incrementOrThrow: Double
  def incrementIsSet: Boolean
  def bucketToFrequency: scala.collection.immutable.Map[Long, Int]
  def bucketToFrequencyOption: Option[scala.collection.immutable.Map[Long, Int]]
  def bucketToFrequencyOrDefault: scala.collection.immutable.Map[Long, Int]
  def bucketToFrequencyOrNull: scala.collection.immutable.Map[Long, Int]
  def bucketToFrequencyOrThrow: scala.collection.immutable.Map[Long, Int]
  def bucketToFrequencyIsSet: Boolean
  def bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  def bucketToPercentileRankOption: Option[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]]
  def bucketToPercentileRankOrDefault: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  def bucketToPercentileRankOrNull: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  def bucketToPercentileRankOrThrow: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  def bucketToPercentileRankIsSet: Boolean
  override def compare(that: GenericStatistics): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.countIsSet.compareTo(that.countIsSet)
      cmp != 0 }) cmp
    else if (this.countIsSet && {
      cmp = this.count.compareTo(that.count)
      cmp != 0 }) cmp
    else if ({
      cmp = this.meanIsSet.compareTo(that.meanIsSet)
      cmp != 0 }) cmp
    else if (this.meanIsSet && {
      cmp = this.mean.compareTo(that.mean)
      cmp != 0 }) cmp
    else if ({
      cmp = this.stdDevIsSet.compareTo(that.stdDevIsSet)
      cmp != 0 }) cmp
    else if (this.stdDevIsSet && {
      cmp = this.stdDev.compareTo(that.stdDev)
      cmp != 0 }) cmp
    else if ({
      cmp = this.sumIsSet.compareTo(that.sumIsSet)
      cmp != 0 }) cmp
    else if (this.sumIsSet && {
      cmp = this.sum.compareTo(that.sum)
      cmp != 0 }) cmp
    else if ({
      cmp = this.sumSquaredIsSet.compareTo(that.sumSquaredIsSet)
      cmp != 0 }) cmp
    else if (this.sumSquaredIsSet && {
      cmp = this.sumSquared.compareTo(that.sumSquared)
      cmp != 0 }) cmp
    else if ({
      cmp = this.incrementIsSet.compareTo(that.incrementIsSet)
      cmp != 0 }) cmp
    else if (this.incrementIsSet && {
      cmp = this.increment.compareTo(that.increment)
      cmp != 0 }) cmp
    else if ({
      cmp = this.bucketToFrequencyIsSet.compareTo(that.bucketToFrequencyIsSet)
      cmp != 0 }) cmp
    else if (this.bucketToFrequencyIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.bucketToFrequency.asJava, that.bucketToFrequency.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.bucketToPercentileRankIsSet.compareTo(that.bucketToPercentileRankIsSet)
      cmp != 0 }) cmp
    else if (this.bucketToPercentileRankIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.bucketToPercentileRank.asJava, that.bucketToPercentileRank.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): GenericStatistics

  def copy(
      count: java.lang.Long = countOrNull,
      mean: java.lang.Double = meanOrNull,
      stdDev: java.lang.Double = stdDevOrNull,
      sum: java.lang.Double = sumOrNull,
      sumSquared: java.lang.Double = sumSquaredOrNull,
      increment: java.lang.Double = incrementOrNull,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrNull,
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrNull
  ): GenericStatistics

  def mutableCopy(): GenericStatistics.Mutable = {
    val ret = GenericStatistics.createRawRecord

    if (countIsSet) ret.count_=(countOrDefault)

    if (meanIsSet) ret.mean_=(meanOrDefault)

    if (stdDevIsSet) ret.stdDev_=(stdDevOrDefault)

    if (sumIsSet) ret.sum_=(sumOrDefault)

    if (sumSquaredIsSet) ret.sumSquared_=(sumSquaredOrDefault)

    if (incrementIsSet) ret.increment_=(incrementOrDefault)

    if (bucketToFrequencyIsSet) ret.bucketToFrequency_=(bucketToFrequencyOrNull)

    if (bucketToPercentileRankIsSet) ret.bucketToPercentileRank_=(bucketToPercentileRankOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: GenericStatistics.Mutable

  def toBuilder(): GenericStatistics.Builder.AllSpecified = {
    val ret = new GenericStatistics.Builder(GenericStatistics.createRawRecord)

    if (countIsSet) ret.count(countOrDefault)

    if (meanIsSet) ret.mean(meanOrDefault)

    if (stdDevIsSet) ret.stdDev(stdDevOrDefault)

    if (sumIsSet) ret.sum(sumOrDefault)

    if (sumSquaredIsSet) ret.sumSquared(sumSquaredOrDefault)

    if (incrementIsSet) ret.increment(incrementOrDefault)

    if (bucketToFrequencyIsSet) ret.bucketToFrequency(bucketToFrequencyOrNull)

    if (bucketToPercentileRankIsSet) ret.bucketToPercentileRank(bucketToPercentileRankOrNull)
    ret
  }

  def mergeCopy(that: GenericStatistics): GenericStatistics

}


trait GenericStatisticsProxy extends GenericStatistics {
  protected def underlying: GenericStatistics

  override def meta: GenericStatistics.type = underlying.meta

// field/proxy_primitive.ssp
  override def count: Long = underlying.count
  override def countOption: Option[Long] = underlying.countOption
  override def countOrDefault: Long = underlying.countOrDefault
  override def countOrNull: java.lang.Long = underlying.countOrNull
  override def countOrThrow: Long = underlying.countOrThrow
  override def countIsSet: Boolean = underlying.countIsSet
// field/proxy_primitive.ssp
  override def mean: Double = underlying.mean
  override def meanOption: Option[Double] = underlying.meanOption
  override def meanOrDefault: Double = underlying.meanOrDefault
  override def meanOrNull: java.lang.Double = underlying.meanOrNull
  override def meanOrThrow: Double = underlying.meanOrThrow
  override def meanIsSet: Boolean = underlying.meanIsSet
// field/proxy_primitive.ssp
  override def stdDev: Double = underlying.stdDev
  override def stdDevOption: Option[Double] = underlying.stdDevOption
  override def stdDevOrDefault: Double = underlying.stdDevOrDefault
  override def stdDevOrNull: java.lang.Double = underlying.stdDevOrNull
  override def stdDevOrThrow: Double = underlying.stdDevOrThrow
  override def stdDevIsSet: Boolean = underlying.stdDevIsSet
// field/proxy_primitive.ssp
  override def sum: Double = underlying.sum
  override def sumOption: Option[Double] = underlying.sumOption
  override def sumOrDefault: Double = underlying.sumOrDefault
  override def sumOrNull: java.lang.Double = underlying.sumOrNull
  override def sumOrThrow: Double = underlying.sumOrThrow
  override def sumIsSet: Boolean = underlying.sumIsSet
// field/proxy_primitive.ssp
  override def sumSquared: Double = underlying.sumSquared
  override def sumSquaredOption: Option[Double] = underlying.sumSquaredOption
  override def sumSquaredOrDefault: Double = underlying.sumSquaredOrDefault
  override def sumSquaredOrNull: java.lang.Double = underlying.sumSquaredOrNull
  override def sumSquaredOrThrow: Double = underlying.sumSquaredOrThrow
  override def sumSquaredIsSet: Boolean = underlying.sumSquaredIsSet
// field/proxy_primitive.ssp
  override def increment: Double = underlying.increment
  override def incrementOption: Option[Double] = underlying.incrementOption
  override def incrementOrDefault: Double = underlying.incrementOrDefault
  override def incrementOrNull: java.lang.Double = underlying.incrementOrNull
  override def incrementOrThrow: Double = underlying.incrementOrThrow
  override def incrementIsSet: Boolean = underlying.incrementIsSet
// field/proxy_container.ssp
  override def bucketToFrequency: scala.collection.immutable.Map[Long, Int] = underlying.bucketToFrequency
  override def bucketToFrequencyOption: Option[scala.collection.immutable.Map[Long, Int]] = underlying.bucketToFrequencyOption
  override def bucketToFrequencyOrDefault: scala.collection.immutable.Map[Long, Int] = underlying.bucketToFrequencyOrDefault
  override def bucketToFrequencyOrNull: scala.collection.immutable.Map[Long, Int] = underlying.bucketToFrequencyOrNull
  override def bucketToFrequencyOrThrow: scala.collection.immutable.Map[Long, Int] = underlying.bucketToFrequencyOrThrow
  override def bucketToFrequencyIsSet: Boolean = underlying.bucketToFrequencyIsSet
// field/proxy_container.ssp
  override def bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = underlying.bucketToPercentileRank
  override def bucketToPercentileRankOption: Option[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]] = underlying.bucketToPercentileRankOption
  override def bucketToPercentileRankOrDefault: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = underlying.bucketToPercentileRankOrDefault
  override def bucketToPercentileRankOrNull: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = underlying.bucketToPercentileRankOrNull
  override def bucketToPercentileRankOrThrow: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = underlying.bucketToPercentileRankOrThrow
  override def bucketToPercentileRankIsSet: Boolean = underlying.bucketToPercentileRankIsSet

  override def compare(that: GenericStatistics): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      count: java.lang.Long = countOrNull,
      mean: java.lang.Double = meanOrNull,
      stdDev: java.lang.Double = stdDevOrNull,
      sum: java.lang.Double = sumOrNull,
      sumSquared: java.lang.Double = sumSquaredOrNull,
      increment: java.lang.Double = incrementOrNull,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrNull,
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrNull
  ): GenericStatistics = underlying.copy(
    count = count,
    mean = mean,
    stdDev = stdDev,
    sum = sum,
    sumSquared = sumSquared,
    increment = increment,
    bucketToFrequency = bucketToFrequency,
    bucketToPercentileRank = bucketToPercentileRank
  )

  override def mutableCopy(): GenericStatistics.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: GenericStatistics): GenericStatistics = underlying.mergeCopy(that)

  override def mutable: GenericStatistics.Mutable = underlying.mutable

  override def deepCopy(): GenericStatistics = underlying.deepCopy()

  override def fieldForId(id: Int): GenericStatistics._Fields = underlying.fieldForId(id)
  override def isSet(field: GenericStatistics._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: GenericStatistics._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: GenericStatistics._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableGenericStatistics extends GenericStatistics {
  def count_=(x: Long): Unit
  def countUnset(): Unit
  def mean_=(x: Double): Unit
  def meanUnset(): Unit
  def stdDev_=(x: Double): Unit
  def stdDevUnset(): Unit
  def sum_=(x: Double): Unit
  def sumUnset(): Unit
  def sumSquared_=(x: Double): Unit
  def sumSquaredUnset(): Unit
  def increment_=(x: Double): Unit
  def incrementUnset(): Unit
  def bucketToFrequency_=(x: scala.collection.immutable.Map[Long, Int]): Unit
  def bucketToFrequencyUnset(): Unit
  def bucketToPercentileRank_=(x: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]): Unit
  def bucketToPercentileRankUnset(): Unit

  def merge(that: GenericStatistics): Unit

  def copy(
      count: java.lang.Long = countOrNull,
      mean: java.lang.Double = meanOrNull,
      stdDev: java.lang.Double = stdDevOrNull,
      sum: java.lang.Double = sumOrNull,
      sumSquared: java.lang.Double = sumSquaredOrNull,
      increment: java.lang.Double = incrementOrNull,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrNull,
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrNull
  ): GenericStatistics.Mutable

  override def mutable: GenericStatistics.Mutable = this
}

trait MutableGenericStatisticsProxy extends MutableGenericStatistics with GenericStatisticsProxy {
  protected def underlying: MutableGenericStatistics

  override def count_=(x: Long): Unit = { underlying.count_=(x) }
  override def countUnset(): Unit = { underlying.countUnset() }
  override def mean_=(x: Double): Unit = { underlying.mean_=(x) }
  override def meanUnset(): Unit = { underlying.meanUnset() }
  override def stdDev_=(x: Double): Unit = { underlying.stdDev_=(x) }
  override def stdDevUnset(): Unit = { underlying.stdDevUnset() }
  override def sum_=(x: Double): Unit = { underlying.sum_=(x) }
  override def sumUnset(): Unit = { underlying.sumUnset() }
  override def sumSquared_=(x: Double): Unit = { underlying.sumSquared_=(x) }
  override def sumSquaredUnset(): Unit = { underlying.sumSquaredUnset() }
  override def increment_=(x: Double): Unit = { underlying.increment_=(x) }
  override def incrementUnset(): Unit = { underlying.incrementUnset() }
  override def bucketToFrequency_=(x: scala.collection.immutable.Map[Long, Int]): Unit = { underlying.bucketToFrequency_=(x) }
  override def bucketToFrequencyUnset(): Unit = { underlying.bucketToFrequencyUnset() }
  override def bucketToPercentileRank_=(x: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]): Unit = { underlying.bucketToPercentileRank_=(x) }
  override def bucketToPercentileRankUnset(): Unit = { underlying.bucketToPercentileRankUnset() }

  override def copy(
      count: java.lang.Long = countOrNull,
      mean: java.lang.Double = meanOrNull,
      stdDev: java.lang.Double = stdDevOrNull,
      sum: java.lang.Double = sumOrNull,
      sumSquared: java.lang.Double = sumSquaredOrNull,
      increment: java.lang.Double = incrementOrNull,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrNull,
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrNull
  ): GenericStatistics.Mutable = underlying.copy(
    count = count,
    mean = mean,
    stdDev = stdDev,
    sum = sum,
    sumSquared = sumSquared,
    increment = increment,
    bucketToFrequency = bucketToFrequency,
    bucketToPercentileRank = bucketToPercentileRank
  )

  override def merge(that: GenericStatistics): Unit = underlying.merge(that)
}



final class RawGenericStatistics extends MutableGenericStatistics {
  override def meta: GenericStatistics.type = GenericStatistics

  // Field #1 - count
  private var _count: Long = 0L  // Underlying type: Long
  private var _countIsSet: Boolean = false
  override def count: Long = countOrDefault
  override def count_=(x: Long): Unit = { _count = x ; _countIsSet = true }
  override def countOption: Option[Long] = if (countIsSet) Some(_count) else None
  override def countOrDefault: Long = _count
  override def countOrNull: java.lang.Long = if (countIsSet) _count else null
  override def countOrThrow: Long = if (countIsSet) _count else throw new java.lang.NullPointerException
  override def countIsSet: Boolean = _countIsSet
  override def countUnset(): Unit = { _countIsSet = false; _count = 0L }
  // Field #2 - mean
  private var _mean: Double = 0.0  // Underlying type: Double
  private var _meanIsSet: Boolean = false
  override def mean: Double = meanOrDefault
  override def mean_=(x: Double): Unit = { _mean = x ; _meanIsSet = true }
  override def meanOption: Option[Double] = if (meanIsSet) Some(_mean) else None
  override def meanOrDefault: Double = _mean
  override def meanOrNull: java.lang.Double = if (meanIsSet) _mean else null
  override def meanOrThrow: Double = if (meanIsSet) _mean else throw new java.lang.NullPointerException
  override def meanIsSet: Boolean = _meanIsSet
  override def meanUnset(): Unit = { _meanIsSet = false; _mean = 0.0 }
  // Field #3 - stdDev
  private var _stdDev: Double = 0.0  // Underlying type: Double
  private var _stdDevIsSet: Boolean = false
  override def stdDev: Double = stdDevOrDefault
  override def stdDev_=(x: Double): Unit = { _stdDev = x ; _stdDevIsSet = true }
  override def stdDevOption: Option[Double] = if (stdDevIsSet) Some(_stdDev) else None
  override def stdDevOrDefault: Double = _stdDev
  override def stdDevOrNull: java.lang.Double = if (stdDevIsSet) _stdDev else null
  override def stdDevOrThrow: Double = if (stdDevIsSet) _stdDev else throw new java.lang.NullPointerException
  override def stdDevIsSet: Boolean = _stdDevIsSet
  override def stdDevUnset(): Unit = { _stdDevIsSet = false; _stdDev = 0.0 }
  // Field #4 - sum
  private var _sum: Double = 0.0  // Underlying type: Double
  private var _sumIsSet: Boolean = false
  override def sum: Double = sumOrDefault
  override def sum_=(x: Double): Unit = { _sum = x ; _sumIsSet = true }
  override def sumOption: Option[Double] = if (sumIsSet) Some(_sum) else None
  override def sumOrDefault: Double = _sum
  override def sumOrNull: java.lang.Double = if (sumIsSet) _sum else null
  override def sumOrThrow: Double = if (sumIsSet) _sum else throw new java.lang.NullPointerException
  override def sumIsSet: Boolean = _sumIsSet
  override def sumUnset(): Unit = { _sumIsSet = false; _sum = 0.0 }
  // Field #5 - sumSquared
  private var _sumSquared: Double = 0.0  // Underlying type: Double
  private var _sumSquaredIsSet: Boolean = false
  override def sumSquared: Double = sumSquaredOrDefault
  override def sumSquared_=(x: Double): Unit = { _sumSquared = x ; _sumSquaredIsSet = true }
  override def sumSquaredOption: Option[Double] = if (sumSquaredIsSet) Some(_sumSquared) else None
  override def sumSquaredOrDefault: Double = _sumSquared
  override def sumSquaredOrNull: java.lang.Double = if (sumSquaredIsSet) _sumSquared else null
  override def sumSquaredOrThrow: Double = if (sumSquaredIsSet) _sumSquared else throw new java.lang.NullPointerException
  override def sumSquaredIsSet: Boolean = _sumSquaredIsSet
  override def sumSquaredUnset(): Unit = { _sumSquaredIsSet = false; _sumSquared = 0.0 }
  // Field #6 - increment
  private var _increment: Double = 0.0  // Underlying type: Double
  private var _incrementIsSet: Boolean = false
  override def increment: Double = incrementOrDefault
  override def increment_=(x: Double): Unit = { _increment = x ; _incrementIsSet = true }
  override def incrementOption: Option[Double] = if (incrementIsSet) Some(_increment) else None
  override def incrementOrDefault: Double = _increment
  override def incrementOrNull: java.lang.Double = if (incrementIsSet) _increment else null
  override def incrementOrThrow: Double = if (incrementIsSet) _increment else throw new java.lang.NullPointerException
  override def incrementIsSet: Boolean = _incrementIsSet
  override def incrementUnset(): Unit = { _incrementIsSet = false; _increment = 0.0 }
  // Field #7 - bucketToFrequency
  private var _bucketToFrequency: scala.collection.immutable.Map[Long, Int] = null  // Underlying type: scala.collection.immutable.Map[Long, Int]
  override def bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrDefault
  override def bucketToFrequency_=(x: scala.collection.immutable.Map[Long, Int]): Unit = { _bucketToFrequency = x }
  override def bucketToFrequencyOption: Option[scala.collection.immutable.Map[Long, Int]] = if (bucketToFrequencyIsSet) Some(_bucketToFrequency) else None
  override def bucketToFrequencyOrDefault: scala.collection.immutable.Map[Long, Int] = if (bucketToFrequencyIsSet) _bucketToFrequency else scala.collection.immutable.Map.empty
  override def bucketToFrequencyOrNull: scala.collection.immutable.Map[Long, Int] = _bucketToFrequency
  override def bucketToFrequencyOrThrow: scala.collection.immutable.Map[Long, Int] = if (bucketToFrequencyIsSet) _bucketToFrequency else throw new java.lang.NullPointerException
  override def bucketToFrequencyIsSet: Boolean = _bucketToFrequency != null
  override def bucketToFrequencyUnset(): Unit = { _bucketToFrequency = null }
  // Field #8 - bucketToPercentileRank
  private var _bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = null  // Underlying type: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]
  override def bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrDefault
  override def bucketToPercentileRank_=(x: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]): Unit = { _bucketToPercentileRank = x }
  override def bucketToPercentileRankOption: Option[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]] = if (bucketToPercentileRankIsSet) Some(_bucketToPercentileRank) else None
  override def bucketToPercentileRankOrDefault: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = if (bucketToPercentileRankIsSet) _bucketToPercentileRank else scala.collection.Seq.empty
  override def bucketToPercentileRankOrNull: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = _bucketToPercentileRank
  override def bucketToPercentileRankOrThrow: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = if (bucketToPercentileRankIsSet) _bucketToPercentileRank else throw new java.lang.NullPointerException
  override def bucketToPercentileRankIsSet: Boolean = _bucketToPercentileRank != null
  override def bucketToPercentileRankUnset(): Unit = { _bucketToPercentileRank = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(GenericStatistics.GENERICSTATISTICS_DESC)
    if (countIsSet) {
      oprot.writeFieldBegin(GenericStatistics.COUNT_DESC)
      oprot.writeI64(_count)
      oprot.writeFieldEnd()
    }
    if (meanIsSet) {
      oprot.writeFieldBegin(GenericStatistics.MEAN_DESC)
      oprot.writeDouble(_mean)
      oprot.writeFieldEnd()
    }
    if (stdDevIsSet) {
      oprot.writeFieldBegin(GenericStatistics.STDDEV_DESC)
      oprot.writeDouble(_stdDev)
      oprot.writeFieldEnd()
    }
    if (sumIsSet) {
      oprot.writeFieldBegin(GenericStatistics.SUM_DESC)
      oprot.writeDouble(_sum)
      oprot.writeFieldEnd()
    }
    if (sumSquaredIsSet) {
      oprot.writeFieldBegin(GenericStatistics.SUMSQUARED_DESC)
      oprot.writeDouble(_sumSquared)
      oprot.writeFieldEnd()
    }
    if (incrementIsSet) {
      oprot.writeFieldBegin(GenericStatistics.INCREMENT_DESC)
      oprot.writeDouble(_increment)
      oprot.writeFieldEnd()
    }
    if (bucketToFrequencyIsSet) {
      oprot.writeFieldBegin(GenericStatistics.BUCKETTOFREQUENCY_DESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I64, org.apache.thrift.protocol.TType.I32, _bucketToFrequency.size))
      _bucketToFrequency.foreach(item => {
        oprot.writeI64(item._1)
        oprot.writeI32(item._2)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
    if (bucketToPercentileRankIsSet) {
      oprot.writeFieldBegin(GenericStatistics.BUCKETTOPERCENTILERANK_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _bucketToPercentileRank.size))
      _bucketToPercentileRank.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        GenericStatistics.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // count

            if (field_header.`type` == org.apache.thrift.protocol.TType.I64) {
              _count = iprot.readI64()

              _countIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // mean

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _mean = iprot.readDouble()

              _meanIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // stdDev

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _stdDev = iprot.readDouble()

              _stdDevIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // sum

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _sum = iprot.readDouble()

              _sumIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // sumSquared

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _sumSquared = iprot.readDouble()

              _sumSquaredIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 6 => {  // increment

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _increment = iprot.readDouble()

              _incrementIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 7 => {  // bucketToFrequency

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _bucketToFrequency = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[Long, Int]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readI64()
                  val v = iprot.readI32()
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 8 => {  // bucketToPercentileRank

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _bucketToPercentileRank = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.foursquare.math.gen.BucketScorePair]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.foursquare.math.gen.BucketScorePair.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure GenericStatistics".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: GenericStatistics): Unit = {
    if (that.countIsSet && !this.countIsSet) {
      this.count_=(that.countOrDefault)
    }
    if (that.meanIsSet && !this.meanIsSet) {
      this.mean_=(that.meanOrDefault)
    }
    if (that.stdDevIsSet && !this.stdDevIsSet) {
      this.stdDev_=(that.stdDevOrDefault)
    }
    if (that.sumIsSet && !this.sumIsSet) {
      this.sum_=(that.sumOrDefault)
    }
    if (that.sumSquaredIsSet && !this.sumSquaredIsSet) {
      this.sumSquared_=(that.sumSquaredOrDefault)
    }
    if (that.incrementIsSet && !this.incrementIsSet) {
      this.increment_=(that.incrementOrDefault)
    }
    if (that.bucketToFrequencyIsSet && !this.bucketToFrequencyIsSet) {
      this.bucketToFrequency_=(that.bucketToFrequencyOrNull)

    } else if (that.bucketToFrequencyIsSet && this.bucketToFrequencyIsSet) {
      this.bucketToFrequency ++= that.bucketToFrequency
    }
    if (that.bucketToPercentileRankIsSet && !this.bucketToPercentileRankIsSet) {
      this.bucketToPercentileRank_=(that.bucketToPercentileRankOrNull)

    } else if (that.bucketToPercentileRankIsSet && this.bucketToPercentileRankIsSet) {
      this.bucketToPercentileRank ++= that.bucketToPercentileRank
    }
  }

  override def mergeCopy(that: GenericStatistics): GenericStatistics = {
    val ret = GenericStatistics.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: GenericStatistics => this.equals(o)
    case _ => false
  }

  def equals(that: GenericStatistics): Boolean = {
    that != null &&
    (if (this.countIsSet) (that.countIsSet && this.countOrDefault == that.countOrDefault) else !that.countIsSet) &&
    (if (this.meanIsSet) (that.meanIsSet && this.meanOrDefault == that.meanOrDefault) else !that.meanIsSet) &&
    (if (this.stdDevIsSet) (that.stdDevIsSet && this.stdDevOrDefault == that.stdDevOrDefault) else !that.stdDevIsSet) &&
    (if (this.sumIsSet) (that.sumIsSet && this.sumOrDefault == that.sumOrDefault) else !that.sumIsSet) &&
    (if (this.sumSquaredIsSet) (that.sumSquaredIsSet && this.sumSquaredOrDefault == that.sumSquaredOrDefault) else !that.sumSquaredIsSet) &&
    (if (this.incrementIsSet) (that.incrementIsSet && this.incrementOrDefault == that.incrementOrDefault) else !that.incrementIsSet) &&
    (if (this.bucketToFrequencyIsSet) (that.bucketToFrequencyIsSet && this.bucketToFrequencyOrNull == that.bucketToFrequencyOrNull) else !that.bucketToFrequencyIsSet) &&
    (if (this.bucketToPercentileRankIsSet) (that.bucketToPercentileRankIsSet && this.bucketToPercentileRankOrNull == that.bucketToPercentileRankOrNull) else !that.bucketToPercentileRankIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (countIsSet) hasher.append(_count.##)
    if (meanIsSet) hasher.append(_mean.##)
    if (stdDevIsSet) hasher.append(_stdDev.##)
    if (sumIsSet) hasher.append(_sum.##)
    if (sumSquaredIsSet) hasher.append(_sumSquared.##)
    if (incrementIsSet) hasher.append(_increment.##)
    if (bucketToFrequencyIsSet) hasher.append(_bucketToFrequency.##)
    if (bucketToPercentileRankIsSet) hasher.append(_bucketToPercentileRank.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (countIsSet) ret = countOrDefault :: ret
    if (meanIsSet) ret = meanOrDefault :: ret
    if (stdDevIsSet) ret = stdDevOrDefault :: ret
    if (sumIsSet) ret = sumOrDefault :: ret
    if (sumSquaredIsSet) ret = sumSquaredOrDefault :: ret
    if (incrementIsSet) ret = incrementOrDefault :: ret
    if (bucketToFrequencyIsSet) ret = bucketToFrequencyOrNull :: ret
    if (bucketToPercentileRankIsSet) ret = bucketToPercentileRankOrNull :: ret
    ret.reverse
  }

  override def clear() {
    countUnset()
    meanUnset()
    stdDevUnset()
    sumUnset()
    sumSquaredUnset()
    incrementUnset()
    bucketToFrequencyUnset()
    bucketToPercentileRankUnset()
  }

  def fieldForId(id: Int): GenericStatistics._Fields = id match {
    case 1 => GenericStatistics._Fields.count
    case 2 => GenericStatistics._Fields.mean
    case 3 => GenericStatistics._Fields.stdDev
    case 4 => GenericStatistics._Fields.sum
    case 5 => GenericStatistics._Fields.sumSquared
    case 6 => GenericStatistics._Fields.increment
    case 7 => GenericStatistics._Fields.bucketToFrequency
    case 8 => GenericStatistics._Fields.bucketToPercentileRank
    case _ => null
  }

  def isSet(field: GenericStatistics._Fields): Boolean = field match {
    case GenericStatistics._Fields.count => countIsSet
    case GenericStatistics._Fields.mean => meanIsSet
    case GenericStatistics._Fields.stdDev => stdDevIsSet
    case GenericStatistics._Fields.sum => sumIsSet
    case GenericStatistics._Fields.sumSquared => sumSquaredIsSet
    case GenericStatistics._Fields.increment => incrementIsSet
    case GenericStatistics._Fields.bucketToFrequency => bucketToFrequencyIsSet
    case GenericStatistics._Fields.bucketToPercentileRank => bucketToPercentileRankIsSet
    case _ => false
  }

  def getFieldValue(field: GenericStatistics._Fields): AnyRef = field match {
    case GenericStatistics._Fields.count => countOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.mean => meanOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.stdDev => stdDevOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.sum => sumOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.sumSquared => sumSquaredOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.increment => incrementOrDefault.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.bucketToFrequency => bucketToFrequencyOrNull.asInstanceOf[AnyRef]
    case GenericStatistics._Fields.bucketToPercentileRank => bucketToPercentileRankOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: GenericStatistics._Fields, value: AnyRef) {
    field match {
      case GenericStatistics._Fields.count => count_=(value.asInstanceOf[Long])
      case GenericStatistics._Fields.mean => mean_=(value.asInstanceOf[Double])
      case GenericStatistics._Fields.stdDev => stdDev_=(value.asInstanceOf[Double])
      case GenericStatistics._Fields.sum => sum_=(value.asInstanceOf[Double])
      case GenericStatistics._Fields.sumSquared => sumSquared_=(value.asInstanceOf[Double])
      case GenericStatistics._Fields.increment => increment_=(value.asInstanceOf[Double])
      case GenericStatistics._Fields.bucketToFrequency => bucketToFrequency_=(value.asInstanceOf[scala.collection.immutable.Map[Long, Int]])
      case GenericStatistics._Fields.bucketToPercentileRank => bucketToPercentileRank_=(value.asInstanceOf[scala.collection.Seq[com.foursquare.math.gen.BucketScorePair]])
      case _ =>
    }
  }

  override def deepCopy(): GenericStatistics.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = GenericStatistics.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      count: java.lang.Long = countOrNull,
      mean: java.lang.Double = meanOrNull,
      stdDev: java.lang.Double = stdDevOrNull,
      sum: java.lang.Double = sumOrNull,
      sumSquared: java.lang.Double = sumSquaredOrNull,
      increment: java.lang.Double = incrementOrNull,
      bucketToFrequency: scala.collection.immutable.Map[Long, Int] = bucketToFrequencyOrNull,
      bucketToPercentileRank: scala.collection.Seq[com.foursquare.math.gen.BucketScorePair] = bucketToPercentileRankOrNull
  ): GenericStatistics.Raw = {
    val ret = new GenericStatistics.Raw
    if (count != null) ret.count_=(count)
    if (mean != null) ret.mean_=(mean)
    if (stdDev != null) ret.stdDev_=(stdDev)
    if (sum != null) ret.sum_=(sum)
    if (sumSquared != null) ret.sumSquared_=(sumSquared)
    if (increment != null) ret.increment_=(increment)
    if (bucketToFrequency != null) ret.bucketToFrequency_=(bucketToFrequency)
    if (bucketToPercentileRank != null) ret.bucketToPercentileRank_=(bucketToPercentileRank)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object CountSumSquared
    extends com.foursquare.spindle.MetaRecord[CountSumSquared]
    with com.foursquare.spindle.RecordProvider[CountSumSquared] {
  override def recordName: String = "CountSumSquared"


  // Thrift descriptors.
  val COUNTSUMSQUARED_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("CountSumSquared")

  val COUNT_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "count",
      org.apache.thrift.protocol.TType.I64,
      1,
      Map[String, String]().asJava
    )
  val SUM_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "sum",
      org.apache.thrift.protocol.TType.DOUBLE,
      2,
      Map[String, String]().asJava
    )
  val SQUARED_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "squared",
      org.apache.thrift.protocol.TType.DOUBLE,
      3,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "count" -> COUNT_DESC,
    "sum" -> SUM_DESC,
    "squared" -> SQUARED_DESC
  )

  object _Fields {
    case object count extends _Fields(1, "count")
    case object sum extends _Fields(2, "sum")
    case object squared extends _Fields(3, "squared")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.count,
    2.toShort -> _Fields.sum,
    3.toShort -> _Fields.squared
  )

  // Record v2
  override type Self = CountSumSquared.type
  override type Trait = CountSumSquared
  override type Mutable = MutableCountSumSquared
  override type Raw = RawCountSumSquared

  override def createRecord: CountSumSquared = createRawRecord
  override def createRawRecord: CountSumSquared.Raw = new CountSumSquared.Raw

  override def ifInstanceFrom(x: AnyRef): Option[CountSumSquared] = {
    if (x.isInstanceOf[CountSumSquared]) Some(x.asInstanceOf[CountSumSquared]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Record v2 Descriptors.


  val count =

    new com.foursquare.spindle.OptionalFieldDescriptor[Long, CountSumSquared, CountSumSquared.type](
      name = "count",
      longName = "count",
      id = 1,
      annotations = Map(),
      owner = CountSumSquared,
      getter = _.countOption,
      setterRaw = (r: CountSumSquared.Raw, v: Long) => { r.count_=(v) },
      manifest = manifest[Long]
    )

  val sum =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, CountSumSquared, CountSumSquared.type](
      name = "sum",
      longName = "sum",
      id = 2,
      annotations = Map(),
      owner = CountSumSquared,
      getter = _.sumOption,
      setterRaw = (r: CountSumSquared.Raw, v: Double) => { r.sum_=(v) },
      manifest = manifest[Double]
    )

  val squared =

    new com.foursquare.spindle.OptionalFieldDescriptor[Double, CountSumSquared, CountSumSquared.type](
      name = "squared",
      longName = "squared",
      id = 3,
      annotations = Map(),
      owner = CountSumSquared,
      getter = _.squaredOption,
      setterRaw = (r: CountSumSquared.Raw, v: Double) => { r.squared_=(v) },
      manifest = manifest[Double]
    )

  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, CountSumSquared, CountSumSquared.type]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, CountSumSquared, CountSumSquared.type]](
      count,
      sum,
      squared
    )


  def apply(
      count: Long,
      sum: Double,
      squared: Double
  ): CountSumSquared = {
    val ret = CountSumSquared.createRawRecord
    ret.count_=(count)
    ret.sum_=(sum)
    ret.squared_=(squared)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[CountSumSquared] (private var obj: CountSumSquared.Raw) {

    def count(v: Long): CountSumSquared.Builder[State] = {
      obj.count_=(v)
      this
    }

    def count(vOpt: Option[Long]): CountSumSquared.Builder[State] = {
      vOpt match {
        case Some(v) => obj.count_=(v)
        case None => obj.countUnset()
      }
      this
    }

    def sum(v: Double): CountSumSquared.Builder[State] = {
      obj.sum_=(v)
      this
    }

    def sum(vOpt: Option[Double]): CountSumSquared.Builder[State] = {
      vOpt match {
        case Some(v) => obj.sum_=(v)
        case None => obj.sumUnset()
      }
      this
    }

    def squared(v: Double): CountSumSquared.Builder[State] = {
      obj.squared_=(v)
      this
    }

    def squared(vOpt: Option[Double]): CountSumSquared.Builder[State] = {
      vOpt match {
        case Some(v) => obj.squared_=(v)
        case None => obj.squaredUnset()
      }
      this
    }

    def resultMutable()(): CountSumSquared.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("CountSumSquared.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): CountSumSquared = resultMutable()()
  }

  def newBuilder: CountSumSquared.Builder.AllUnspecified = new Builder(CountSumSquared.createRawRecord)

  implicit val companionProvider: CountSumSquaredCompanionProvider = new CountSumSquaredCompanionProvider
}

class CountSumSquaredCompanionProvider extends com.foursquare.spindle.CompanionProvider[CountSumSquared] {
  type CompanionT = CountSumSquared.type
  override def provide: CountSumSquared.type = CountSumSquared
}



trait CountSumSquared

    extends com.foursquare.spindle.Record[CountSumSquared]
    with scala.Ordered[CountSumSquared]
    with org.apache.thrift.TBase[CountSumSquared, CountSumSquared._Fields] {

  override type MetaT = CountSumSquared.type

  def count: Long
  def countOption: Option[Long]
  def countOrDefault: Long
  def countOrNull: java.lang.Long
  def countOrThrow: Long
  def countIsSet: Boolean
  def sum: Double
  def sumOption: Option[Double]
  def sumOrDefault: Double
  def sumOrNull: java.lang.Double
  def sumOrThrow: Double
  def sumIsSet: Boolean
  def squared: Double
  def squaredOption: Option[Double]
  def squaredOrDefault: Double
  def squaredOrNull: java.lang.Double
  def squaredOrThrow: Double
  def squaredIsSet: Boolean
  override def compare(that: CountSumSquared): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.countIsSet.compareTo(that.countIsSet)
      cmp != 0 }) cmp
    else if (this.countIsSet && {
      cmp = this.count.compareTo(that.count)
      cmp != 0 }) cmp
    else if ({
      cmp = this.sumIsSet.compareTo(that.sumIsSet)
      cmp != 0 }) cmp
    else if (this.sumIsSet && {
      cmp = this.sum.compareTo(that.sum)
      cmp != 0 }) cmp
    else if ({
      cmp = this.squaredIsSet.compareTo(that.squaredIsSet)
      cmp != 0 }) cmp
    else if (this.squaredIsSet && {
      cmp = this.squared.compareTo(that.squared)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): CountSumSquared

  def copy(
      count: java.lang.Long = countOrNull,
      sum: java.lang.Double = sumOrNull,
      squared: java.lang.Double = squaredOrNull
  ): CountSumSquared

  def mutableCopy(): CountSumSquared.Mutable = {
    val ret = CountSumSquared.createRawRecord

    if (countIsSet) ret.count_=(countOrDefault)

    if (sumIsSet) ret.sum_=(sumOrDefault)

    if (squaredIsSet) ret.squared_=(squaredOrDefault)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: CountSumSquared.Mutable

  def toBuilder(): CountSumSquared.Builder.AllSpecified = {
    val ret = new CountSumSquared.Builder(CountSumSquared.createRawRecord)

    if (countIsSet) ret.count(countOrDefault)

    if (sumIsSet) ret.sum(sumOrDefault)

    if (squaredIsSet) ret.squared(squaredOrDefault)
    ret
  }

  def mergeCopy(that: CountSumSquared): CountSumSquared

}


trait CountSumSquaredProxy extends CountSumSquared {
  protected def underlying: CountSumSquared

  override def meta: CountSumSquared.type = underlying.meta

// field/proxy_primitive.ssp
  override def count: Long = underlying.count
  override def countOption: Option[Long] = underlying.countOption
  override def countOrDefault: Long = underlying.countOrDefault
  override def countOrNull: java.lang.Long = underlying.countOrNull
  override def countOrThrow: Long = underlying.countOrThrow
  override def countIsSet: Boolean = underlying.countIsSet
// field/proxy_primitive.ssp
  override def sum: Double = underlying.sum
  override def sumOption: Option[Double] = underlying.sumOption
  override def sumOrDefault: Double = underlying.sumOrDefault
  override def sumOrNull: java.lang.Double = underlying.sumOrNull
  override def sumOrThrow: Double = underlying.sumOrThrow
  override def sumIsSet: Boolean = underlying.sumIsSet
// field/proxy_primitive.ssp
  override def squared: Double = underlying.squared
  override def squaredOption: Option[Double] = underlying.squaredOption
  override def squaredOrDefault: Double = underlying.squaredOrDefault
  override def squaredOrNull: java.lang.Double = underlying.squaredOrNull
  override def squaredOrThrow: Double = underlying.squaredOrThrow
  override def squaredIsSet: Boolean = underlying.squaredIsSet

  override def compare(that: CountSumSquared): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      count: java.lang.Long = countOrNull,
      sum: java.lang.Double = sumOrNull,
      squared: java.lang.Double = squaredOrNull
  ): CountSumSquared = underlying.copy(
    count = count,
    sum = sum,
    squared = squared
  )

  override def mutableCopy(): CountSumSquared.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: CountSumSquared): CountSumSquared = underlying.mergeCopy(that)

  override def mutable: CountSumSquared.Mutable = underlying.mutable

  override def deepCopy(): CountSumSquared = underlying.deepCopy()

  override def fieldForId(id: Int): CountSumSquared._Fields = underlying.fieldForId(id)
  override def isSet(field: CountSumSquared._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: CountSumSquared._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: CountSumSquared._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableCountSumSquared extends CountSumSquared {
  def count_=(x: Long): Unit
  def countUnset(): Unit
  def sum_=(x: Double): Unit
  def sumUnset(): Unit
  def squared_=(x: Double): Unit
  def squaredUnset(): Unit

  def merge(that: CountSumSquared): Unit

  def copy(
      count: java.lang.Long = countOrNull,
      sum: java.lang.Double = sumOrNull,
      squared: java.lang.Double = squaredOrNull
  ): CountSumSquared.Mutable

  override def mutable: CountSumSquared.Mutable = this
}

trait MutableCountSumSquaredProxy extends MutableCountSumSquared with CountSumSquaredProxy {
  protected def underlying: MutableCountSumSquared

  override def count_=(x: Long): Unit = { underlying.count_=(x) }
  override def countUnset(): Unit = { underlying.countUnset() }
  override def sum_=(x: Double): Unit = { underlying.sum_=(x) }
  override def sumUnset(): Unit = { underlying.sumUnset() }
  override def squared_=(x: Double): Unit = { underlying.squared_=(x) }
  override def squaredUnset(): Unit = { underlying.squaredUnset() }

  override def copy(
      count: java.lang.Long = countOrNull,
      sum: java.lang.Double = sumOrNull,
      squared: java.lang.Double = squaredOrNull
  ): CountSumSquared.Mutable = underlying.copy(
    count = count,
    sum = sum,
    squared = squared
  )

  override def merge(that: CountSumSquared): Unit = underlying.merge(that)
}



final class RawCountSumSquared extends MutableCountSumSquared {
  override def meta: CountSumSquared.type = CountSumSquared

  // Field #1 - count
  private var _count: Long = 0L  // Underlying type: Long
  private var _countIsSet: Boolean = false
  override def count: Long = countOrDefault
  override def count_=(x: Long): Unit = { _count = x ; _countIsSet = true }
  override def countOption: Option[Long] = if (countIsSet) Some(_count) else None
  override def countOrDefault: Long = _count
  override def countOrNull: java.lang.Long = if (countIsSet) _count else null
  override def countOrThrow: Long = if (countIsSet) _count else throw new java.lang.NullPointerException
  override def countIsSet: Boolean = _countIsSet
  override def countUnset(): Unit = { _countIsSet = false; _count = 0L }
  // Field #2 - sum
  private var _sum: Double = 0.0  // Underlying type: Double
  private var _sumIsSet: Boolean = false
  override def sum: Double = sumOrDefault
  override def sum_=(x: Double): Unit = { _sum = x ; _sumIsSet = true }
  override def sumOption: Option[Double] = if (sumIsSet) Some(_sum) else None
  override def sumOrDefault: Double = _sum
  override def sumOrNull: java.lang.Double = if (sumIsSet) _sum else null
  override def sumOrThrow: Double = if (sumIsSet) _sum else throw new java.lang.NullPointerException
  override def sumIsSet: Boolean = _sumIsSet
  override def sumUnset(): Unit = { _sumIsSet = false; _sum = 0.0 }
  // Field #3 - squared
  private var _squared: Double = 0.0  // Underlying type: Double
  private var _squaredIsSet: Boolean = false
  override def squared: Double = squaredOrDefault
  override def squared_=(x: Double): Unit = { _squared = x ; _squaredIsSet = true }
  override def squaredOption: Option[Double] = if (squaredIsSet) Some(_squared) else None
  override def squaredOrDefault: Double = _squared
  override def squaredOrNull: java.lang.Double = if (squaredIsSet) _squared else null
  override def squaredOrThrow: Double = if (squaredIsSet) _squared else throw new java.lang.NullPointerException
  override def squaredIsSet: Boolean = _squaredIsSet
  override def squaredUnset(): Unit = { _squaredIsSet = false; _squared = 0.0 }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(CountSumSquared.COUNTSUMSQUARED_DESC)
    if (countIsSet) {
      oprot.writeFieldBegin(CountSumSquared.COUNT_DESC)
      oprot.writeI64(_count)
      oprot.writeFieldEnd()
    }
    if (sumIsSet) {
      oprot.writeFieldBegin(CountSumSquared.SUM_DESC)
      oprot.writeDouble(_sum)
      oprot.writeFieldEnd()
    }
    if (squaredIsSet) {
      oprot.writeFieldBegin(CountSumSquared.SQUARED_DESC)
      oprot.writeDouble(_squared)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        CountSumSquared.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // count

            if (field_header.`type` == org.apache.thrift.protocol.TType.I64) {
              _count = iprot.readI64()

              _countIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // sum

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _sum = iprot.readDouble()

              _sumIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // squared

            if (field_header.`type` == org.apache.thrift.protocol.TType.DOUBLE) {
              _squared = iprot.readDouble()

              _squaredIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure CountSumSquared".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: CountSumSquared): Unit = {
    if (that.countIsSet && !this.countIsSet) {
      this.count_=(that.countOrDefault)
    }
    if (that.sumIsSet && !this.sumIsSet) {
      this.sum_=(that.sumOrDefault)
    }
    if (that.squaredIsSet && !this.squaredIsSet) {
      this.squared_=(that.squaredOrDefault)
    }
  }

  override def mergeCopy(that: CountSumSquared): CountSumSquared = {
    val ret = CountSumSquared.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: CountSumSquared => this.equals(o)
    case _ => false
  }

  def equals(that: CountSumSquared): Boolean = {
    that != null &&
    (if (this.countIsSet) (that.countIsSet && this.countOrDefault == that.countOrDefault) else !that.countIsSet) &&
    (if (this.sumIsSet) (that.sumIsSet && this.sumOrDefault == that.sumOrDefault) else !that.sumIsSet) &&
    (if (this.squaredIsSet) (that.squaredIsSet && this.squaredOrDefault == that.squaredOrDefault) else !that.squaredIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (countIsSet) hasher.append(_count.##)
    if (sumIsSet) hasher.append(_sum.##)
    if (squaredIsSet) hasher.append(_squared.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (countIsSet) ret = countOrDefault :: ret
    if (sumIsSet) ret = sumOrDefault :: ret
    if (squaredIsSet) ret = squaredOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    countUnset()
    sumUnset()
    squaredUnset()
  }

  def fieldForId(id: Int): CountSumSquared._Fields = id match {
    case 1 => CountSumSquared._Fields.count
    case 2 => CountSumSquared._Fields.sum
    case 3 => CountSumSquared._Fields.squared
    case _ => null
  }

  def isSet(field: CountSumSquared._Fields): Boolean = field match {
    case CountSumSquared._Fields.count => countIsSet
    case CountSumSquared._Fields.sum => sumIsSet
    case CountSumSquared._Fields.squared => squaredIsSet
    case _ => false
  }

  def getFieldValue(field: CountSumSquared._Fields): AnyRef = field match {
    case CountSumSquared._Fields.count => countOrDefault.asInstanceOf[AnyRef]
    case CountSumSquared._Fields.sum => sumOrDefault.asInstanceOf[AnyRef]
    case CountSumSquared._Fields.squared => squaredOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: CountSumSquared._Fields, value: AnyRef) {
    field match {
      case CountSumSquared._Fields.count => count_=(value.asInstanceOf[Long])
      case CountSumSquared._Fields.sum => sum_=(value.asInstanceOf[Double])
      case CountSumSquared._Fields.squared => squared_=(value.asInstanceOf[Double])
      case _ =>
    }
  }

  override def deepCopy(): CountSumSquared.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = CountSumSquared.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      count: java.lang.Long = countOrNull,
      sum: java.lang.Double = sumOrNull,
      squared: java.lang.Double = squaredOrNull
  ): CountSumSquared.Raw = {
    val ret = new CountSumSquared.Raw
    if (count != null) ret.count_=(count)
    if (sum != null) ret.sum_=(sum)
    if (squared != null) ret.squared_=(squared)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}



